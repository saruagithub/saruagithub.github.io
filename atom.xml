<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WangXue</title>
  
  <subtitle>1 笨笨的孩子慢慢学stay hungry stay foolish 2 武汉加油！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-10-22T14:48:56.245Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>WangXue</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Stop JIT Hot Spot Counting</title>
    <link href="http://yoursite.com/2022/10/22/20220823%20Stop%20JIT%20hot%20spot%20counting/"/>
    <id>http://yoursite.com/2022/10/22/20220823%20Stop%20JIT%20hot%20spot%20counting/</id>
    <published>2022-10-22T14:51:17.000Z</published>
    <updated>2022-10-22T14:48:56.245Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h4 id="PHP-Tracing-JIT"><a href="#PHP-Tracing-JIT" class="headerlink" title="PHP Tracing  JIT"></a>PHP Tracing  JIT</h4><p>PHP 的tracing JIT是PHP中加速效果比较好的，JIT开启的默认配置就是tracing模式。tracing模式会跟踪经常执行的loop或者function，然后将执行路径（trace）编译成机器码，以后再执行此段代码的时候会直接执行机器码，这样更快。</p><a id="more"></a><blockquote><p>A trace is a linear sequence of instructions with a single entry point and one or more exit points. A trace does not contain any inner control-flow join points execution either continues on the trace or it exits the trace.  </p></blockquote><p>其中进行JIT编译的主要的代码类型有loop，function，return，side_exit. 相应的用户可调整的参数是opcache.jit_hot_loop， opcache.jit_hot_func， opcache.jit_hot_return，opcache.jit_hot_side_exit，这些参数的初始值及初始值见官方文档 <a href="https://www.php.net/manual/en/opcache.configuration.php#ini.opcache.jit-hot-func" target="_blank" rel="noopener">opcache configuration</a> 。比如hot_func，当PHP解释执行n次之后 达到了opcache.jit_hot_func 设置的阈值，则触发JIT编译。</p><p>本文关心的则是PHP怎么实现的热点代码的计数，怎么判断达到了阈值，以及我做的一点点停掉热点计数的优化。</p><h3 id="Original-Code"><a href="#Original-Code" class="headerlink" title="Original Code"></a>Original Code</h3><h4 id="call-stack"><a href="#call-stack" class="headerlink" title="call stack"></a>call stack</h4><p>先简单写个函数调用的PHP脚本add.php，然后去GDB调试，<code>gdb ./sapi/cli/php</code>,  <code>run -c php.ini add.php</code> 先看看这个call stack</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bt</span><br><span class="line">#0  zend_jit_setup_hot_trace_counters (op_array=0x7fffb4cdb4e0) at ext/opcache/jit/zend_jit_trace.c:8069</span><br><span class="line">#1  0x00007ffff54d1c96 in zend_jit_op_array (op_array=0x7fffb4cdb4e0, script=0x7fffb4cdb280)</span><br><span class="line">    at /home/wxue/wxue/php-src/ext/opcache/jit/zend_jit.c:4512</span><br><span class="line">#2  0x00007ffff53bec59 in zend_persist_op_array (zv=0x7fffb4cdb4c0) at /home/wxue/wxue/php-src/ext/opcache/zend_persist.c:700</span><br><span class="line">#3  0x00007ffff53c3ac0 in zend_accel_script_persist (script=0x7fffb4cdb280, for_shm=0x1)</span><br><span class="line">    at /home/wxue/wxue/php-src/ext/opcache/zend_persist.c:1320</span><br><span class="line">#4  0x00007ffff53acc50 in cache_script_in_shared_memory (new_persistent_script=0x7ffff5879000,</span><br><span class="line">    key=0x7ffff55100b8 &lt;accel_globals+408&gt;, from_shared_memory=0x7fffffffa9a0)</span><br><span class="line">    at /home/wxue/wxue/php-src/ext/opcache/ZendAccelerator.c:1600</span><br><span class="line">#5  0x00007ffff53aea8f in persistent_compile_file (file_handle=0x7fffffffd000, type=0x8)</span><br><span class="line">    at /home/wxue/wxue/php-src/ext/opcache/ZendAccelerator.c:2169</span><br><span class="line">#6  0x0000555555c21c7c in zend_execute_scripts (type=0x8, retval=0x0, file_count=0x3) at /home/wxue/wxue/php-src/Zend/zend.c:1754</span><br><span class="line">#7  0x0000555555b7ec84 in php_execute_script (primary_file=0x7fffffffd000) at /home/wxue/wxue/php-src/main/main.c:2538</span><br><span class="line">#8  0x0000555555d97b5d in do_cli (argc=0x4, argv=0x555556b8dc10) at /home/wxue/wxue/php-src/sapi/cli/php_cli.c:965</span><br><span class="line">#9  0x0000555555d98c65 in main (argc=0x4, argv=0x555556b8dc10) at /home/wxue/wxue/php-src/sapi/cli/php_cli.c:1367</span><br></pre></td></tr></table></figure><p>以#4 cache_script_in_shared_memory 为界，前面的函数主要是去将PHP源码解析抽象语法树，最后创建一个包含 op_array （一条条的opline）的script结构 （相关的PHP虚拟机的博客可以参考这个 <a href="https://www.npopov.com/2017/04/14/PHP-7-Virtual-machine.html" target="_blank" rel="noopener">PHP7 Virtua Machine</a>。每次遇到一个.php 的文件就会走一遍这个过程。</p><p>cache_script_in_shared_memory  做的事情呢主要是将编译出来的op_array这些缓存到opcache里去，这是个共享内存，在PHP的worker之间共享。</p><p>后续的函数呢就是去加速脚本执行，JIT也是在做加速，相关的热点计数的逻辑在zend_jit_setup_hot_trace_counters里。其中zend_jit_setup_hot_trace_counters就是对op_array里的那些loop，func等起始位置设置上计数功能。</p><h4 id="zend-jit-setup-hot-trace-counters"><a href="#zend-jit-setup-hot-trace-counters" class="headerlink" title="zend_jit_setup_hot_trace_counters()"></a>zend_jit_setup_hot_trace_counters()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">if (JIT_G(hot_loop)) &#123;</span><br><span class="line">zend_cfg cfg;</span><br><span class="line">ZEND_ASSERT(zend_jit_loop_trace_counter_handler != NULL);</span><br><span class="line"></span><br><span class="line">// 构建控制流图，分析基本块(basic block 指令顺序执行的一个整块)，因为loop的识别是基于基本块识别的</span><br><span class="line">if (zend_jit_build_cfg(op_array, &amp;cfg) != SUCCESS) &#123;</span><br><span class="line">return FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对所有的基本块遍历，识别出loop_header (ZEND_BB_LOOP_HEADER)</span><br><span class="line">for (i = 0; i &lt; cfg.blocks_count; i++) &#123;</span><br><span class="line">if (cfg.blocks[i].flags &amp; ZEND_BB_REACHABLE) &#123;</span><br><span class="line">if (cfg.blocks[i].flags &amp; ZEND_BB_LOOP_HEADER) &#123;</span><br><span class="line">/* loop header */</span><br><span class="line">opline = op_array-&gt;opcodes + cfg.blocks[i].start;</span><br><span class="line">if (!(ZEND_OP_TRACE_INFO(opline, jit_extension-&gt;offset)-&gt;trace_flags &amp; ZEND_JIT_TRACE_UNSUPPORTED)) &#123;</span><br><span class="line">// 关键一步，修改opline的handler，原来 的opline-&gt;handler 是 (const void *) 0x555555cd4d39 &lt;execute_ex+7817&gt; ,</span><br><span class="line">// 被替换为 (const void *) 0x7ffff3edc6b0 &lt;JIT$$hybrid_func_trace_counter&gt; 这个函数就是对counter进行操作的逻辑</span><br><span class="line">opline-&gt;handler = (const void*)zend_jit_loop_trace_counter_handler;</span><br><span class="line"></span><br><span class="line">if (!ZEND_OP_TRACE_INFO(opline, jit_extension-&gt;offset)-&gt;counter) &#123;</span><br><span class="line">// 这个counter其实是保存的地址，zend_jit_hot_counters数组的第ZEND_JIT_COUNTER_NUM个位置</span><br><span class="line">// 整个zend_jit_hot_counters数组size是 ZEND_HOT_COUNTERS_COUNT=128, </span><br><span class="line">// 也就是说所有的loop 和 func的计数器都保存在这个数组里，</span><br><span class="line">// 那么这也限制了在整个.php脚本里最多支持对128个loop func 进行计数，</span><br><span class="line">// 检测是否达到阈值成为热点代码.</span><br><span class="line">ZEND_OP_TRACE_INFO(opline, jit_extension-&gt;offset)-&gt;counter =</span><br><span class="line">&amp;zend_jit_hot_counters[ZEND_JIT_COUNTER_NUM];</span><br><span class="line">ZEND_JIT_COUNTER_NUM = (ZEND_JIT_COUNTER_NUM + 1) % ZEND_HOT_COUNTERS_COUNT;</span><br><span class="line">&#125;</span><br><span class="line">// 设置trace_flag，表示这条handler是tracing JIT loop 起始的位置。</span><br><span class="line">ZEND_OP_TRACE_INFO(opline, jit_extension-&gt;offset)-&gt;trace_flags |=</span><br><span class="line">ZEND_JIT_TRACE_START_LOOP;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// if (JIT_G(hot_func)) 类似</span><br></pre></td></tr></table></figure><p>后续当再次执行到设置了计数handler（zend_jit_loop_trace_counter_handler）的opline的时候，就会触发对counter的计算来判断是否满足hot。而这个handler在不同的zend_jit_vm_kind模式下对应的函数不太一样。dasm_labels 里的最终会由 DynASM 去生成汇编码执行，比如对func的计数handler会被替换成JIT$$hybrid_func_trace_counter，这个handler因为被经常执行，已经被当作桩函数给提前JIT生成了汇编码。不过它的逻辑和下面的zend_jit_func_trace_helper是一样的，我们可以之间看zend_jit_func_trace_helper的C代码，更方便一些。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static void zend_jit_init_handlers(void)</span><br><span class="line">&#123;</span><br><span class="line">if (zend_jit_vm_kind == ZEND_VM_KIND_HYBRID) &#123;</span><br><span class="line">// ...</span><br><span class="line">zend_jit_func_trace_counter_handler = dasm_labels[zend_lbhybrid_func_trace_counter];</span><br><span class="line">zend_jit_ret_trace_counter_handler = dasm_labels[zend_lbhybrid_ret_trace_counter];</span><br><span class="line">zend_jit_loop_trace_counter_handler = dasm_labels[zend_lbhybrid_loop_trace_counter];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// ...</span><br><span class="line">zend_jit_func_trace_counter_handler = (const void*)zend_jit_func_trace_helper;</span><br><span class="line">zend_jit_ret_trace_counter_handler = (const void*)zend_jit_ret_trace_helper;</span><br><span class="line">zend_jit_loop_trace_counter_handler = (const void*)zend_jit_loop_trace_helper;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static zend_always_inline ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_jit_trace_counter_helper(uint32_t cost ZEND_OPCODE_HANDLER_ARGS_DC)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">// PHP VM每次执行到带了tracing计数handler的opline，这里的counter就会每次减cost，</span><br><span class="line">// 这个cost是个定值，即((ZEND_JIT_COUNTER_INIT + JIT_G(hot_func) - 1) / JIT_G(hot_func)))</span><br><span class="line">*(ZEND_OP_TRACE_INFO(opline, offset)-&gt;counter) -= cost;</span><br><span class="line"></span><br><span class="line">// 当小于等于0的时候表示达到了阈值，即变成了热点代码，</span><br><span class="line">// 需要对其进行JIT编译，调用zend_jit_trace_hot_root进入录制执行路径的过程。</span><br><span class="line">if (UNEXPECTED(*(ZEND_OP_TRACE_INFO(opline, offset)-&gt;counter) &lt;= 0)) &#123;</span><br><span class="line">*(ZEND_OP_TRACE_INFO(opline, offset)-&gt;counter) = ZEND_JIT_COUNTER_INIT;</span><br><span class="line">if (UNEXPECTED(zend_jit_trace_hot_root(execute_data, opline) &lt; 0)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// zend_jit_vm_helpers.h 最后调用到zend_jit_trace_counter_helper</span><br><span class="line">ZEND_OPCODE_HANDLER_RET ZEND_FASTCALL zend_jit_func_trace_helper(ZEND_OPCODE_HANDLER_ARGS)</span><br><span class="line">&#123;</span><br><span class="line">ZEND_OPCODE_TAIL_CALL_EX(zend_jit_trace_counter_helper,</span><br><span class="line">((ZEND_JIT_COUNTER_INIT + JIT_G(hot_func) - 1) / JIT_G(hot_func)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h3><p>上面基本梳理了计数的代码，接下来是我在测试过程中发现的一个小问题，即当JIT编译了足够多的代码之后，JIT停止以后这些计数功能还在继续执行，带来了一点overhead。毕竟多执行了几个函数，还有counter占了一些cache，还导致了一些错误的分支预测。</p><p>所以我想将这些计数功能停止，关键思路其实就是将那些带有计数handler（JIT$$hybrid_func_trace_counter）的opline的handler再设置回原始的由VM 执行的 handler （<execute_ex+7817>）。</execute_ex+7817></p><p>优化的代码见GitHub <a href="https://github.com/php/php-src/pull/9343" target="_blank" rel="noopener">PR9343</a> , 相关的注释和讨论都有。</p><p>整个实现逻辑里关键的一步就是怎么将所有带有计数handler的那些opline给找出来，需要去遍历存在opcache里的所有script。这个逻辑其实是参考的前面对编译好的脚本缓存进opcache的逻辑。</p><p>其实在PHP里opcache将编译的脚本缓存是个非常重要的功能，这部分的实现后续有机会会再写一篇博客。</p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ol><li>一些汇编码看起来还是有点痛苦，有时候可以先看简单的类似的逻辑。比如zend_jit_func_trace_helper这里。</li><li>GDB的命令很强大，内存里的数值也可以看  <code>x/hd 0x7ffff5519524</code>, 0x7ffff5519524 <zend_jit_hot_counters+4>:       32531</zend_jit_hot_counters+4></li><li>数据结构体很多的时候，注意梳理数据结构</li></ol><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol><li><a href="https://php.watch/articles/jit-in-depth" target="_blank" rel="noopener">jit-in-depth</a></li><li><a href="https://www.php.net/manual/en/opcache.configuration.php#ini.opcache.jit" target="_blank" rel="noopener">opcache.jit</a></li><li><a href="https://github.com/php/php-src/pull/9343/files" target="_blank" rel="noopener">PR</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;h4 id=&quot;PHP-Tracing-JIT&quot;&gt;&lt;a href=&quot;#PHP-Tracing-JIT&quot; class=&quot;headerlink&quot; title=&quot;PHP Tracing  JIT&quot;&gt;&lt;/a&gt;PHP Tracing  JIT&lt;/h4&gt;&lt;p&gt;PHP 的tracing JIT是PHP中加速效果比较好的，JIT开启的默认配置就是tracing模式。tracing模式会跟踪经常执行的loop或者function，然后将执行路径（trace）编译成机器码，以后再执行此段代码的时候会直接执行机器码，这样更快。&lt;/p&gt;
    
    </summary>
    
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="PHP-SRC" scheme="http://yoursite.com/tags/PHP-SRC/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="JIT" scheme="http://yoursite.com/tags/JIT/"/>
    
  </entry>
  
  <entry>
    <title>编译、链接和生成的目标文件</title>
    <link href="http://yoursite.com/2022/09/25/20220925%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E7%94%9F%E6%88%90%E7%9A%84%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2022/09/25/20220925%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E7%94%9F%E6%88%90%E7%9A%84%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/</id>
    <published>2022-09-25T12:31:17.000Z</published>
    <updated>2022-09-25T13:35:31.493Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编译、链接和生成的目标文件"><a href="#编译、链接和生成的目标文件" class="headerlink" title="编译、链接和生成的目标文件"></a>编译、链接和生成的目标文件</h3><h4 id="基础编译链接知识"><a href="#基础编译链接知识" class="headerlink" title="基础编译链接知识"></a>基础编译链接知识</h4><p>gcc编译C程序经过预处理，编译，汇编，链接。</p><p>GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器。</p><h5 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h5><p><img src="/images/20220925compile_link.png" alt="image-20220925194018558"></p><p>预处理就是展开所有的头文件、替换程序中的宏、解析条件编译并添加到文件中。</p><p>c语言中条件编译相关的预编译指令，包括  #define、#undef、#ifdef、#ifndef、#if、#elif、#else、#endif、defined。</p><a id="more"></a><p>删除所有的注释。添加行号和文件名标识，保留所有的 #pragma 编译器指令。</p><p><code>gcc -E test.c -o test.i</code> preprocessing 显示的预处理之后的源代码。</p><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><p>编译：编译是将经过预编译处理的代码编译成汇编代码。对预处理后的.i文件进行词法分析，语法分析，语义分析及优化等等。</p><p>这里就是编译原理会涉及的东西，扫描，词法（有限状态机）语法（语法树 yacc）语义分析（对语法树的表达式标识类型），中间语言生成（IR 三地址码等），源码优化（优化寻址等），代码生成和目标代码优化等等。</p><p><code>gcc -S test.i -o test.s</code> 可直接对生成的test.i文件编译，生成汇编代码</p><p><code>/usr/lib/gcc/x86_64-linux-gnu/5.4.0/cc1 test.c</code> 现在版本的gcc将预编译和编译俩步骤合并到了一起，cc1这个程序。</p><h5 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h5><p>将汇编代码转变为机器可以执行的指令，就根据汇编指令和机器指令的对照表去一一翻译即可。</p><p><code>gcc -c test.s -o test.o</code> 汇编Assembly，gas汇编器负责将其编译为目标文件，.o文件是机器代码 （即 目标文件）</p><p><code>as -c test.s -o test.o</code> 直接调用汇编器来做也可以。</p><h5 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h5><p><code>gcc test.o -o test</code>  将程序的目标文件与所需的所有附加的目标文件连接起来，最终生成可执行文件。附加的目标文件包括静态连接库和动态连接库。</p><p>ld其实会将许许多多的文件链接起来，包括一些glibc里的库文件的 .o 文件等等。</p><p>链接工作无非是把一些指令对其他符号地址的引用加以修正，解决了各个模块间符号引用的问题。主要过程有地址和空间的分配，符号决议（symbol resolution）和重定位等。</p><h4 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h4><ol><li>重定位relocation：重新计算每个子程序或跳转的目标地址，然后把所有引用到这个符号的指令修正到正确的地址。这种重新计算各个目标地址的过程是重定位。</li><li>静态链接的基本过程：链接器在链接的时候，会根据你所引用的符号foo，自动去相应的func.c 模块查找foo的地址，然后将main.c模块中所有引用到foo的指令重新修正，让他们的目标地址为真正的foo函数的地址。</li></ol><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol><li>《程序员的自我修养》</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;编译、链接和生成的目标文件&quot;&gt;&lt;a href=&quot;#编译、链接和生成的目标文件&quot; class=&quot;headerlink&quot; title=&quot;编译、链接和生成的目标文件&quot;&gt;&lt;/a&gt;编译、链接和生成的目标文件&lt;/h3&gt;&lt;h4 id=&quot;基础编译链接知识&quot;&gt;&lt;a href=&quot;#基础编译链接知识&quot; class=&quot;headerlink&quot; title=&quot;基础编译链接知识&quot;&gt;&lt;/a&gt;基础编译链接知识&lt;/h4&gt;&lt;p&gt;gcc编译C程序经过预处理，编译，汇编，链接。&lt;/p&gt;&lt;p&gt;GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器。&lt;/p&gt;&lt;h5 id=&quot;预编译&quot;&gt;&lt;a href=&quot;#预编译&quot; class=&quot;headerlink&quot; title=&quot;预编译&quot;&gt;&lt;/a&gt;预编译&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;/images/20220925compile_link.png&quot; alt=&quot;image-20220925194018558&quot;&gt;&lt;/p&gt;&lt;p&gt;预处理就是展开所有的头文件、替换程序中的宏、解析条件编译并添加到文件中。&lt;/p&gt;&lt;p&gt;c语言中条件编译相关的预编译指令，包括  #define、#undef、#ifdef、#ifndef、#if、#elif、#else、#endif、defined。&lt;/p&gt;
    
    </summary>
    
    
      <category term="底层原理" scheme="http://yoursite.com/categories/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译链接" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5/"/>
    
      <category term="底层原理" scheme="http://yoursite.com/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>mmap代码段JIT buffer重定位</title>
    <link href="http://yoursite.com/2022/06/13/20220713mmap%E4%BB%A3%E7%A0%81%E6%AE%B5JIT%20buffer%E9%87%8D%E5%AE%9A%E4%BD%8D/"/>
    <id>http://yoursite.com/2022/06/13/20220713mmap%E4%BB%A3%E7%A0%81%E6%AE%B5JIT%20buffer%E9%87%8D%E5%AE%9A%E4%BD%8D/</id>
    <published>2022-06-13T14:51:17.000Z</published>
    <updated>2022-10-22T14:48:50.034Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JIT-buffer重定位"><a href="#JIT-buffer重定位" class="headerlink" title="JIT buffer重定位"></a>JIT buffer重定位</h3><h4 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h4><h5 id="PHP8-JIT"><a href="#PHP8-JIT" class="headerlink" title="PHP8 JIT"></a>PHP8 JIT</h5><p>Just-In-Time compilation is a hybrid model of interpreter and Ahead-of-Time compilation, that some or all of the code is compiled, often at run-time, without requiring the developer to manually compile it. </p><a id="more"></a><p>JIT也就是边解释执行代码，找到热点代码将其编译，以后就直接去执行编译成机器码的热点代码，提高性能。JIT</p><blockquote><p>JavaScript Performance Penalty. Function calls between embedded builtins and JIT compiled code can come at a considerable performance penalty. With the x86-64 instruction set,  we can’t use direct calls. Instead, we need to rely on indirect calls through a register or memory operand. Such calls rely more heavily on prediction since it’s not immediately apparent from the call instruction itself what the target of the call is.</p><p>For 64-bit applications, branch prediction performance can be negatively impacted when the target of a branch is more than 4 GB away from the branch.  </p></blockquote><p>JIT生成机器码之后，从编译好的code跳转到解释执行的code，这之间是存在性能损失的，因为Intel对这种远距离的分支跳转，分支预测得不准（似乎是有对分支跳转的距离假设，比如函数A跳转到函数B的虚拟地址一般是在4GB以内）。</p><p>思考：那PHP里的JIT buffer的位置是在哪呢？ 跳转到PHP的解释器执行的代码的情况如何呢？ 是否也可以对这个远距离跳转去优化呢？</p><h4 id="JIT-buffer内存布局"><a href="#JIT-buffer内存布局" class="headerlink" title="JIT buffer内存布局"></a>JIT buffer内存布局</h4><p>我们跑了wordpress的workload，php.ini的配置中如下两项配置了opcache的最大值和jit buffer的最大值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">opcache.memory_consumption=1024</span><br><span class="line">; The size of the shared memory storage used by OPcache, in megabytes.</span><br><span class="line"></span><br><span class="line">opcache.jit_buffer_size=128M</span><br><span class="line">; The amount of shared memory to reserve for compiled JIT code. A zero value disables the JIT.</span><br><span class="line"></span><br><span class="line">opcache.huge_code_pages=1</span><br><span class="line">; Enables or disables copying of PHP code (text segment) into HUGE PAGES. This should improve performance</span><br></pre></td></tr></table></figure><p>跑workload 用户发出请求由php处理的过程中，查看任意php-fpm 的进程的内存使用maps文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/1888419/maps</span><br><span class="line"><span class="comment"># open hugepage， /proc/sys/vm/nr_hugepages = 20000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># start addr-end addr     perms offset  dev   inode                  pathname</span></span><br><span class="line">555555400000-5555554f9000 r--p 00000000 08:02 6166492                    /opt/pkb/git/hhvm-perf/php-fpm-wp5.8-php8.1.4-jit.bolt</span><br><span class="line"><span class="comment"># PHP .text is put into the huge page</span></span><br><span class="line">555555600000-555555a00000 r-xp 00000000 00:0f 285761873                  /anon_hugepage (deleted)</span><br><span class="line">555555a00000-555556231000 r--p 00600000 08:02 6166492                    /opt/pkb/git/hhvm-perf/php-fpm-wp5.8-php8.1.4-jit.bolt</span><br><span class="line">55555655f000-555556600000 r--p 00f5f000 08:02 6166492                    /opt/pkb/git/hhvm-perf/php-fpm-wp5.8-php8.1.4-jit.bolt</span><br><span class="line">555556600000-555556604000 rw-p 01000000 08:02 6166492                    /opt/pkb/git/hhvm-perf/php-fpm-wp5.8-php8.1.4-jit.bolt</span><br><span class="line">555556604000-555556624000 rw-p 00000000 00:00 0</span><br><span class="line">555556800000-555556ca4000 r-xp 01400000 08:02 6166492                    /opt/pkb/git/hhvm-perf/php-fpm-wp5.8-php8.1.4-jit.bolt</span><br><span class="line">555556ca4000-555556ebe000 rw-p 00000000 00:00 0                          [heap]</span><br><span class="line">555556ebe000-555556f19000 rw-p 00000000 00:00 0                          [heap]</span><br><span class="line">7fffad3f0000-7fffad400000 rwxp 00000000 00:00 0</span><br><span class="line">7fffad400000-7fffad600000 rw-p 00000000 00:0f 285734811                  /anon_hugepage (deleted)</span><br><span class="line"><span class="comment"># here 1024 MB Opcache</span></span><br><span class="line">7fffad600000-7fffed600000 rw<span class="_">-s</span> 00000000 00:0f 285761874                  /anon_hugepage (deleted)</span><br><span class="line"><span class="comment"># here 128M JIT Buffer</span></span><br><span class="line">7fffed600000-7ffff5600000 r-xs 40000000 00:0f 285761874                  /anon_hugepage (deleted)</span><br><span class="line">7ffff560b000-7ffff565b000 rwxp 00000000 00:00 0</span><br><span class="line">7ffff565b000-7ffff56dc000 rw-p 00000000 00:00 0</span><br><span class="line">7ffff56e0000-7ffff56f0000 rwxp 00000000 00:00 0</span><br><span class="line">7ffff56f0000-7ffff5705000 rw<span class="_">-s</span> 00000000 00:01 135173                     /dev/zero (deleted)</span><br><span class="line">7ffff5705000-7ffff571a000 r--p 00000000 08:02 6166503                    /opt/pkb/git/hhvm-perf/opcache-wp5.8-php8.1.4-jit.so</span><br><span class="line">7ffff571a000-7ffff57cb000 r-xp 00015000 08:02 6166503                    /opt/pkb/git/hhvm-perf/opcache-wp5.8-php8.1.4-jit.so</span><br><span class="line">7ffff57cb000-7ffff57e4000 r--p 000c6000 08:02 6166503                    /opt/pkb/git/hhvm-perf/opcache-wp5.8-php8.1.4-jit.so</span><br><span class="line">7ffff57e4000-7ffff57e7000 r--p 000de000 08:02 6166503                    /opt/pkb/git/hhvm-perf/opcache-wp5.8-php8.1.4-jit.so</span><br><span class="line">7ffff57e7000-7ffff57f7000 rw-p 000e1000 08:02 6166503                    /opt/pkb/git/hhvm-perf/opcache-wp5.8-php8.1.4-jit.so</span><br></pre></td></tr></table></figure><p>可以看到 7fffed600000 这里JIT 跳转进入到555555600000 php的.text 段，距离是很远的，far jump会有性能损失。</p><p>注意，当 opcache.jit_buffer_size=16M , opcache.memory_consumption=128M 的时候，mmap会分配到＜2GB的位置上去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># opcache</span></span><br><span class="line">40000000-48000000 rw<span class="_">-s</span> 00000000 00:0f 286759728                          /anon_hugepage (deleted)</span><br><span class="line"><span class="comment"># jit buffer</span></span><br><span class="line">48000000-49000000 r-xs 08000000 00:0f 286759728                          /anon_hugepage (deleted)</span><br><span class="line">555555400000-5555554f9000 r--p 00000000 08:02 6166492                    /opt/pkb/git/hhvm-perf/php-fpm-wp5.8-php8.1.4-jit.bolt</span><br><span class="line">555555600000-555555a00000 r-xp 00000000 00:0f 286759727                  /anon_hugepage (deleted)</span><br><span class="line">555555a00000-555556231000 r--p 00600000 08:02 6166492                    /opt/pkb/git/hhvm-perf/php-fpm-wp5.8-php8.1.4-jit.bolt</span><br><span class="line">55555655f000-555556600000 r--p 00f5f000 08:02 6166492                    /opt/pkb/git/hhvm-perf/php-fpm-wp5.8-php8.1.4-jit.bolt</span><br><span class="line">555556600000-555556604000 rw-p 01000000 08:02 6166492                    /opt/pkb/git/hhvm-perf/php-fpm-wp5.8-php8.1.4-jit.bolt</span><br><span class="line">555556604000-555556624000 rw-p 00000000 00:00 0</span><br><span class="line">555556800000-555556ca4000 r-xp 01400000 08:02 6166492                    /opt/pkb/git/hhvm-perf/php-fpm-wp5.8-php8.1.4-jit.bolt</span><br><span class="line">555556ca4000-555556ebe000 rw-p 00000000 00:00 0                          [heap]</span><br><span class="line">555556ebe000-555556f19000 rw-p 00000000 00:00 0                          [heap]</span><br></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h4><p>代码思路在代码注释里写的很清晰了，就是在分配JIT buffer之前（函数create_segments），找一段空闲的内存空间，距离 PHP .text 段在4GB以内的都可以。</p><p><a href="https://github.com/stkeke/php-src/commit/7ccc2a9209af156a9da0619b22e0be12f0adc2ab" target="_blank" rel="noopener">https://github.com/stkeke/php-src/commit/7ccc2a9209af156a9da0619b22e0be12f0adc2ab</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">We will search for any candidates BEFORE and AFTER PHP .text segment.</span></span><br><span class="line"><span class="comment">        E.g., [hole0], [hole1], [hole2], and [hole3] all might be good</span></span><br><span class="line"><span class="comment">        candidates. We have verified that using [hole3] as jit buffer will not</span></span><br><span class="line"><span class="comment">        block or affect heap growth for later memory allocation.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(MAP_HUGETLB)</span></span><br><span class="line"><span class="comment">/* Do jit buffer relocation, only if requested buffer size is</span></span><br><span class="line"><span class="comment">       greater than at least one huge page and takes up multiple huge pages.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (requested_size &gt;= huge_page_size &amp;&amp;</span><br><span class="line">        requested_size % huge_page_size == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Try mmap all candidate address, return if any one succeeds. */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candidate_count; i++) &#123;</span><br><span class="line">            res = mmap((<span class="keyword">void</span>*)candidates[i], requested_size, flags,</span><br><span class="line">                       MAP_SHARED|MAP_ANONYMOUS|MAP_HUGETLB|MAP_FIXED, fd, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (MAP_FAILED != res) &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* MAP_HUGETLB */</span></span></span><br></pre></td></tr></table></figure><p>后续maintainer修改了这个patch，更简洁一些。</p><p><a href="https://github.com/php/php-src/commit/17aa81a5e22d4b8d1ffd7c89cb641939b4f6b7db" target="_blank" rel="noopener">https://github.com/php/php-src/commit/17aa81a5e22d4b8d1ffd7c89cb641939b4f6b7db</a></p><p>最后JIT Buffer的位置被移动到了heap之后，或者一开始的位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">555513e00000-555553e00000 rw<span class="_">-s</span> 00000000 00:0f 287680313                  /anon_hugepage (deleted)</span><br><span class="line">555553e00000-555555200000 r-xs 40000000 00:0f 287680313                  /anon_hugepage (deleted)</span><br><span class="line">555555400000-5555554f9000 r--p 00000000 08:02 11403879                   /opt/pkb/git/hhvm-perf/php-fpm-wp5.8-php8.1.4-jit.bolt</span><br><span class="line">555555600000-555555a00000 r-xp 00000000 00:0f 287680312                  /anon_hugepage (deleted)</span><br><span class="line">555555a00000-555556231000 r--p 00600000 08:02 11403879                   /opt/pkb/git/hhvm-perf/php-fpm-wp5.8-php8.1.4-jit.bolt</span><br><span class="line">55555655f000-555556600000 r--p 00f5f000 08:02 11403879                   /opt/pkb/git/hhvm-perf/php-fpm-wp5.8-php8.1.4-jit.bolt</span><br><span class="line">555556600000-555556604000 rw-p 01000000 08:02 11403879                   /opt/pkb/git/hhvm-perf/php-fpm-wp5.8-php8.1.4-jit.bolt</span><br><span class="line">555556604000-555556624000 rw-p 00000000 00:00 0</span><br><span class="line">555556800000-555556ca4000 r-xp 01400000 08:02 11403879                   /opt/pkb/git/hhvm-perf/php-fpm-wp5.8-php8.1.4-jit.bolt</span><br><span class="line">555556ca4000-555556ebe000 rw-p 00000000 00:00 0                          [heap]</span><br><span class="line">555556ebe000-555556f19000 rw-p 00000000 00:00 0                          [heap]</span><br><span class="line">7ffff53f0000-7ffff5400000 rwxp 00000000 00:00 0</span><br><span class="line">7ffff5400000-7ffff5600000 rw-p 00000000 00:0f 287683296                  /anon_hugepage (deleted)</span><br></pre></td></tr></table></figure><p>代码已经合并到php-src社区，好久没写C了，这里总结一些写代码时遇到的思考和问题。</p><ol><li>用函数指针可以获取代码段所在的位置。void* addr = php_text_lighthouse;</li><li>注意ifdef的使用中，不存在的代码最后不会被编译进binary，要注意到hugepage 变量的定义，避免出现未定义的问题。</li><li>注意区分数据类型，uintptr_t 表示地址，任何指向void的合法指针都可以转化为这个类型。 ptrdiff_t 有符号整数类型，两个指针相减结果的类型。表示地址之间的距离。 size_t 表示大小,是无符号整数类型，这是sizeof操作符结果的类型。</li><li>函数参数是数组指针的时候，最好还传一个数组的max_size，避免越界</li><li>减少if的嵌套</li><li>用中间变量保存一些计算步骤，让代码更易读</li><li>提PR的时候写好注释，所有关键地方都写上，方便maintainer阅读</li></ol><h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><p>性能优化四个方向：CPU/内存&amp;网卡&amp;磁盘&amp;应用</p><p>优化代码段的布局，将常常调用的代码都放到4GB以内（for X64）。</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ol><li><a href="https://v8.dev/blog/short-builtin-calls" target="_blank" rel="noopener">Short builtin calls</a></li><li><p><a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf" target="_blank" rel="noopener">Intel Optimization Manual</a></p></li><li><p><a href="https://www.php.net/manual/en/opcache.configuration.php#ini.opcache.jit-buffer-size" target="_blank" rel="noopener">PHP: Runtime Configuration - Manual</a></p></li><li><p><a href="https://bbs.huaweicloud.com/blogs/201857" target="_blank" rel="noopener">基于硬件特性的性能调优</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JIT-buffer重定位&quot;&gt;&lt;a href=&quot;#JIT-buffer重定位&quot; class=&quot;headerlink&quot; title=&quot;JIT buffer重定位&quot;&gt;&lt;/a&gt;JIT buffer重定位&lt;/h3&gt;&lt;h4 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h4&gt;&lt;h5 id=&quot;PHP8-JIT&quot;&gt;&lt;a href=&quot;#PHP8-JIT&quot; class=&quot;headerlink&quot; title=&quot;PHP8 JIT&quot;&gt;&lt;/a&gt;PHP8 JIT&lt;/h5&gt;&lt;p&gt;Just-In-Time compilation is a hybrid model of interpreter and Ahead-of-Time compilation, that some or all of the code is compiled, often at run-time, without requiring the developer to manually compile it. &lt;/p&gt;
    
    </summary>
    
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="PHP-SRC" scheme="http://yoursite.com/tags/PHP-SRC/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="内存布局" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
    
      <category term="JIT" scheme="http://yoursite.com/tags/JIT/"/>
    
  </entry>
  
  <entry>
    <title>kmp字符串匹配</title>
    <link href="http://yoursite.com/2020/10/04/20201004kmp%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <id>http://yoursite.com/2020/10/04/20201004kmp%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</id>
    <published>2020-10-04T09:51:17.000Z</published>
    <updated>2022-07-13T14:17:15.794Z</updated>
    
    <content type="html"><![CDATA[<h3 id="KMP字符串匹配"><a href="#KMP字符串匹配" class="headerlink" title="KMP字符串匹配"></a>KMP字符串匹配</h3><p>找出模式串里后缀和前缀相同的地方。比如test = “aabaabaac” , pattern = “aabaac”， 进行匹配的时候在pattern的最后的字符c处无法匹配，则看pattern的后缀aa和前面test的下标0处的aa相同，可以再针对下标2处的b进行继续匹配。</p><p>next数组存的就是当test和pattern匹配不上的时候应该从新从pattern的哪开始重新匹配，图中是next数组计算的过程。next数组的具体过程见图（备注：图红色的字应该是指针不后移）：</p><a id="more"></a><p><img src="/images/20201004_str_KMP.jpg" alt="20201004_str_KMP"></p><p>下图是在俩字符串进行匹配过程中，next数组的使用方法：</p><p><img src="/images/20201004str_KMP1.jpg" alt="20201004str_KMP1"></p><p>算法，返回的ans是匹配上了在text的起始位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp_strStr</span><span class="params">(<span class="built_in">string</span> &amp;test, <span class="built_in">string</span> &amp;pattern)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>; i &lt;pattern.<span class="built_in">size</span>();) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern[i] == pattern[j]) &#123;</span><br><span class="line">            next[i] = j + <span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//go back</span></span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                next[i] = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//the location of match</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; test.<span class="built_in">size</span>(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (test[i] == pattern[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="comment">// pattern reachs the end, all matched</span></span><br><span class="line">            <span class="keyword">if</span> (j == pattern.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                ans = i - j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//j go back</span></span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_kmp_strStr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> test, pattern;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; test &gt;&gt; pattern;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; kmp_strStr(test,pattern) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sunday算法"><a href="#Sunday算法" class="headerlink" title="Sunday算法"></a>Sunday算法</h3><p>如果pattern和text没有匹配上，看test对应pattern的下一个字符，这个字符应该会参与到下一轮的字符比较中，因此可以根据这个字符对pattern进行移动匹配。见图：</p><p><img src="/images/20201004Sunday_algorithm.jpg" alt="20201004Sunday_algorithm"></p><p>算法参考实现，注意每一轮匹配之后pattern的指针需要重置为0：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sunday: string match algorithm</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sunday_strStr</span><span class="params">(<span class="built_in">string</span> &amp;<span class="built_in">text</span>, <span class="built_in">string</span> &amp;pattern)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对应的字符最后一次出现在pattern中的位置</span></span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// init the length, the char never show in pattern</span></span><br><span class="line">        num[i] = pattern.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        num[pattern[i]] = pattern.<span class="built_in">size</span>() - i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//i起始位置 + pattern的长度 &lt;= 文本长度，就一直匹配；一轮匹配之后pattern的指针重置为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i + pattern.<span class="built_in">size</span>() &lt;= <span class="built_in">text</span>.<span class="built_in">size</span>(); j = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; pattern.<span class="built_in">size</span>() &amp;&amp; pattern[j] == <span class="built_in">text</span>[i+j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// match success</span></span><br><span class="line">        <span class="keyword">if</span> (j == pattern.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">//i do not move</span></span><br><span class="line">            ans = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// match failed, then i = i + num[?]</span></span><br><span class="line">        i += num[<span class="built_in">text</span>[i + pattern.<span class="built_in">size</span>()]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;KMP字符串匹配&quot;&gt;&lt;a href=&quot;#KMP字符串匹配&quot; class=&quot;headerlink&quot; title=&quot;KMP字符串匹配&quot;&gt;&lt;/a&gt;KMP字符串匹配&lt;/h3&gt;&lt;p&gt;找出模式串里后缀和前缀相同的地方。比如test = “aabaabaac” , pattern = “aabaac”， 进行匹配的时候在pattern的最后的字符c处无法匹配，则看pattern的后缀aa和前面test的下标0处的aa相同，可以再针对下标2处的b进行继续匹配。&lt;/p&gt;&lt;p&gt;next数组存的就是当test和pattern匹配不上的时候应该从新从pattern的哪开始重新匹配，图中是next数组计算的过程。next数组的具体过程见图（备注：图红色的字应该是指针不后移）：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Leecode" scheme="http://yoursite.com/tags/Leecode/"/>
    
  </entry>
  
  <entry>
    <title>数学类算法题目</title>
    <link href="http://yoursite.com/2020/08/27/20200827%E6%95%B0%E5%AD%A6%E7%B1%BB%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"/>
    <id>http://yoursite.com/2020/08/27/20200827%E6%95%B0%E5%AD%A6%E7%B1%BB%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/</id>
    <published>2020-08-27T06:32:04.000Z</published>
    <updated>2022-07-13T14:17:15.793Z</updated>
    
    <content type="html"><![CDATA[<h3 id="位数交换"><a href="#位数交换" class="headerlink" title="位数交换"></a>位数交换</h3><p>第一题就是按照他的先一个数字每两位交换，然后第二步后一个数字的高两位是他前一个数字右移出来的两位，第一个数字的高两位是最后一个数字的低两位。比如输入1 2，输出是1073741824，2147483648。</p><p>1、转换成二进制01字符串，二进制字符串填充成32bit长度；</p><p>2、交换奇偶位，完成交换操作，比如0001 -&gt; 0010；</p><a id="more"></a><p>3，对整数向右移动两位，将所有移位后的二进制字符串拼接在一起，将最后两个字符放到拼接字符的最前面，并去除这最后的两个字符，完成移位操作；</p><p>4、将最后的字符串按32bit长度划分，得到原来的n个整数的二进制字符串，将二进制字符串转换成整数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一题就是按照他的先一个数字每两位交换 unsigned int -&gt; 32位</span></span><br><span class="line"><span class="comment">//然后第二步后一个数字的高两位是他前一个数字右移出来的两位，第一个数字的高两位是最后一个数字的低两位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="keyword">char</span> ch=<span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch!=<span class="string">'\n'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">        data.push_back(temp);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = data.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> temp[<span class="number">33</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="number">32</span>;j=j+<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[j+<span class="number">1</span>]= ((data[i]&gt;&gt;(<span class="number">32</span>-j))&amp;<span class="number">1</span>)&lt;&lt;(<span class="number">32</span>-j<span class="number">-1</span>);</span><br><span class="line">            temp[j]= ((data[i]&gt;&gt;(<span class="number">32</span>-j<span class="number">-1</span>))&amp;<span class="number">1</span>)&lt;&lt;(<span class="number">32</span>-j);</span><br><span class="line">        &#125;</span><br><span class="line">        data[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">32</span>;j++)</span><br><span class="line">            data[i]=data[i]|temp[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> t1=<span class="number">0</span>,t2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> f1=t1,f2=t2; <span class="comment">//first int, f1 = 0, f2 = 0</span></span><br><span class="line">        t1=(data[i]&amp;<span class="number">1</span>)&lt;&lt;<span class="number">30</span>;</span><br><span class="line">        t2=((data[i]&gt;&gt;<span class="number">1</span>)&amp;<span class="number">1</span>)&lt;&lt;<span class="number">31</span>;</span><br><span class="line">        data[i]=(data[i]&gt;&gt;<span class="number">2</span>)|f1|f2;</span><br><span class="line">    &#125;</span><br><span class="line">    data[<span class="number">0</span>]=data[<span class="number">0</span>]|t1|t2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;data[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求抛物线与直线围城的面积"><a href="#求抛物线与直线围城的面积" class="headerlink" title="求抛物线与直线围城的面积"></a>求抛物线与直线围城的面积</h3><p>求抛物线 $y^2 = 2Ax $ 与直线 $y=Bx+C$ 所围城的封闭图形面积。若图形不存在，则输出0。</p><p><img src="/images/20200828areaCurve.jpg" alt="20200828抛物线面积"></p><p>这个题目本来是跟积分相关的，代入化简得到其一元二次的形式 $B^2x^2+(2BC-2A)x+C^2=0$，用求根公式得俩解x1,x2：</p><script type="math/tex; mode=display">x_1, x_2 = \frac{(A-BC) \pm \sqrt{A^2-2ABC}}{B^2}</script><p>思路是可以从求梯形面积 - 曲线与y轴的积分面积 $\int_{y_1}^{y_2} y^2/2A \mathrm{dy}$。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    float A,B,C;</span><br><span class="line">    cin&gt;&gt;A&gt;&gt;B&gt;&gt;C;</span><br><span class="line">    if( (4 * pow(A, 2) - 8 * A * B * C) &lt; 0)&#123;</span><br><span class="line">        cout&lt;&lt;&quot;0&quot;&lt;&lt;endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;;</span><br><span class="line">    float x1=0.0, x2=0.0, area=0.0;</span><br><span class="line">    if(C == 0)&#123;</span><br><span class="line">        if(A&lt;0) A = -A;</span><br><span class="line">        if(B&lt;0) B = -B;</span><br><span class="line">        x1 = 0;</span><br><span class="line">        x2 = 2*A/pow(B, 2);</span><br><span class="line">        area = 0.5 * abs(x2) * sqrt(abs(2*A*x2)) - pow((sqrt(abs(2*A*x2))),3)/6/A;</span><br><span class="line">        cout&lt;&lt;x1&lt;&lt;&quot; &quot;&lt;&lt;x2&lt;&lt;&quot; &quot;&lt;&lt;area&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        x1 = ((2*A-2*B*C) + sqrt(4*pow(A, 2) - 8*A*B*C))/2*pow(B, 2);</span><br><span class="line">        x2 = ((2*A-2*B*C) - sqrt(4*pow(A, 2) - 8*A*B*C))/2*pow(B, 2);</span><br><span class="line">        float y1,y2;</span><br><span class="line">        y1 = B*x1+C;</span><br><span class="line">        y2 = B*x2+C;</span><br><span class="line">        area = y1&gt;y2? (abs(x1) + abs(x2)) * (y1-y2) * 0.5 - (pow(y1, 3) - pow(y2, 3))/6/A : (abs(x1) + abs(x2)) * (y2-y1) * 0.5 - (pow(y2, 3) - pow(y1, 3))/6/A;</span><br><span class="line">        cout&lt;&lt;x1&lt;&lt;&quot; &quot;&lt;&lt;x2&lt;&lt;&quot; &quot;&lt;&lt;area&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，<a href="https://www.nowcoder.com/discuss/489735?type=post&amp;order=time&amp;pos=&amp;page=1&amp;channel=1011&amp;source_id=search_post#" target="_blank" rel="noopener">华为8.26笔试题</a></p><p>2，<a href="https://www.nowcoder.com/discuss/418098?type=2" target="_blank" rel="noopener">腾讯笔试题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;位数交换&quot;&gt;&lt;a href=&quot;#位数交换&quot; class=&quot;headerlink&quot; title=&quot;位数交换&quot;&gt;&lt;/a&gt;位数交换&lt;/h3&gt;&lt;p&gt;第一题就是按照他的先一个数字每两位交换，然后第二步后一个数字的高两位是他前一个数字右移出来的两位，第一个数字的高两位是最后一个数字的低两位。比如输入1 2，输出是1073741824，2147483648。&lt;/p&gt;&lt;p&gt;1、转换成二进制01字符串，二进制字符串填充成32bit长度；&lt;/p&gt;&lt;p&gt;2、交换奇偶位，完成交换操作，比如0001 -&amp;gt; 0010；&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>20200709守护进程学习</title>
    <link href="http://yoursite.com/2020/07/09/20200709%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/07/09/20200709%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-07-09T04:23:16.000Z</published>
    <updated>2022-07-13T14:17:15.792Z</updated>
    
    <content type="html"><![CDATA[<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程是在后台运行不受终端控制的进程（如输入、输出等），一般的网络服务都是以守护进程的方式运行。守护进程脱离终端的主要原因有两点：</p><p>（1）用来启动守护进程的终端在启动守护进程之后，需要执行其他任务。</p><p>（2）（如其他用户登录该终端后，以前的守护进程的错误信息不应出现）由终端上的一些键所产生的信号（如中断信号），不应对以前从该终端上启动的任何守护进程造成影响。要注意守护进程与后台运行程序（即加＆启动的程序）的区别。</p><a id="more"></a><h4 id="创建守护进程的过程"><a href="#创建守护进程的过程" class="headerlink" title="创建守护进程的过程"></a>创建守护进程的过程</h4><h5 id="第一次调用fork创建子进程，父进程退出。"><a href="#第一次调用fork创建子进程，父进程退出。" class="headerlink" title="第一次调用fork创建子进程，父进程退出。"></a>第一次调用fork创建子进程，父进程退出。</h5><p>父进程终止，让子进程在后台继续执行。父进程退出后，子进程其实就是变成了孤儿进程，孤儿进程一般是由1号进程收养，也就是我们所谓的init进程，也就是说原来的子进程变成了init的子进程。</p><p>第一次调用fork函数时，<a href="https://baike.baidu.com/item/子进程" target="_blank" rel="noopener">子进程</a>全盘拷贝父进程的会话期(session，是一个或多个进程组的集合)、进程组、控制终端等，虽然父进程退出了，但原先的会话期、进程组、控制终端等并没有改变，因此，那还不是真正意义上使两者独立开来。</p><p>（之后所有的工作都在子进程中完成，而用户在shell终端里则可以执行其他的命令，从而使得程序以僵尸进程形式运行，在形式上做到了与控制终端的脱离。）</p><h5 id="子进程调用setsid创建新会话（important）"><a href="#子进程调用setsid创建新会话（important）" class="headerlink" title="子进程调用setsid创建新会话（important）"></a>子进程调用setsid创建新会话（important）</h5><p>会话期：会话期(session)是一个或多个进程组的集合。</p><p>进程组：每个进程属于一个进程组；每个进程主都有一个进程组号，该号等于该进程组组长的PID号；一个进程只能为它自己或子进程设置进程组ID号。</p><p>子进程调用调用系统函数setsid() 可以建立一个新的会话。如果，调用setsid的进程不是一个进程组的组长，此函数创建一个新的会话期。</p><p>(1 )此进程变成该对话期的首进程</p><p>(2) 此进程变成一个新进程组的组长进程。</p><p>(3) 此进程没有控制终端，如果在调用setsid前，该进程有控制终端，那么与该终端的联系被解除。 如果该进程是一个进程组的组长，此函数返回错误。</p><p>(4) 为了保证这一点，我们先调用fork()然后exit()，此时只有子进程在运行</p><p>作用：进程脱离原会话的控制，摆脱了原进程组的控制，摆脱了原控制终端的控制。</p><h5 id="忽略SIGHUP信号"><a href="#忽略SIGHUP信号" class="headerlink" title="忽略SIGHUP信号"></a>忽略SIGHUP信号</h5><p>会话组长进程终止会向其他进程发该信号，造成其他进程终止。</p><h5 id="第二次调用fork创建实际服务子进程"><a href="#第二次调用fork创建实际服务子进程" class="headerlink" title="第二次调用fork创建实际服务子进程"></a>第二次调用fork创建实际服务子进程</h5><p>第二次调用fork再创建子进程。子进程终止，子子进程继续执行，由于子子进程不再是会话组长，从而禁止进程重新打开控制终端。并作为父进程观测子进程状态。</p><h5 id="改变工作目录"><a href="#改变工作目录" class="headerlink" title="改变工作目录"></a>改变工作目录</h5><p>改变当前工作目录为根目录。一般将工作目录改变到根目录，这样进程的启动目录也可以被卸掉。在fork子进程的时候，子进程也继承了父进程的工作目录。通常是让‘/’目录作为守护进程的当前目录，可以避免很多麻烦。</p><p>关闭打开的文件描述符，打开一个空设备，并复制到标准输出和标准错误上。 避免调用的一些库函数依然向屏幕输出信息。</p><h5 id="重设文件创建掩码"><a href="#重设文件创建掩码" class="headerlink" title="重设文件创建掩码"></a>重设文件创建掩码</h5><p>重设文件创建掩码清除从父进程那里继承来的文件创建掩码，设为0。文件创建掩码是指屏蔽掉文件创建时的对应位。由于使用fork函数新建的子进程继承了父进程的文件创建掩码，这就给该子进程使用文件带来了诸多的麻烦。因此，把文件创建掩码设置为0，可以大大增强该守护进程的灵活性。设置文件创建掩码的函数是umask，通常的使用方法为umask(0)。</p><p>用openlog函数建立与syslogd的连接。</p><h5 id="关闭文件描述符"><a href="#关闭文件描述符" class="headerlink" title="关闭文件描述符"></a>关闭文件描述符</h5><p>守护进程没有控制终端，因此当某些情况发生时，不管是一般的报告性信息，还是需由管理员处理的紧急信息，都需要以某种方式输出。Syslog 函数就是输出这些信息的标准方法，它把信息发送给 syslogd 守护进程。</p><h4 id="按照服务类型分类"><a href="#按照服务类型分类" class="headerlink" title="按照服务类型分类"></a>按照服务类型分类</h4><ol><li>系统守护进程：syslogd、login、crond、at等。守护进程程序的名称通常以字母“d”结尾：例如，<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/Syslog">syslogd</a> 就是指管理系统日志的守护进程。</li><li>网络守护进程：sendmail、httpd、xinetd、等。</li><li>独立启动的守护进程：httpd、named、xinetd等。</li><li>被动守护进程（由xinetd启动）：telnet、finger、ktalk等。</li></ol><p>Linux系统有自己的守护进程管理工具 Systemd 。它是操作系统的一部分，直接与内核交互，性能出色，功能极其强大。我们完全可以将程序交给 Systemd ，让系统统一管理，成为真正意义上的系统服务。</p><h4 id="守护进程与后台运行程序（即加＆启动的程序）的区别。"><a href="#守护进程与后台运行程序（即加＆启动的程序）的区别。" class="headerlink" title="守护进程与后台运行程序（即加＆启动的程序）的区别。"></a>守护进程与后台运行程序（即加＆启动的程序）的区别。</h4><p>最大的区别有几点：</p><p>(a)守护进程已经完全脱离终端控制台了，而后台程序并未完全脱离终端，在终端未关闭前还是会往终端输出结果</p><p>(b)守护进程在关闭终端控制台时不会受影响，而后台程序会随用户退出而停止，需要在以nohup command &amp; 格式运行才能避免影响</p><p>(c)守护进程的会话组和当前目录，文件描述符都是独立的。后台运行只是终端进行了一次fork，让程序在后台执行，这些都没改变。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，<a href="https://www.zhihu.com/question/38609004" target="_blank" rel="noopener">https://www.zhihu.com/question/38609004</a></p><p>2，<a href="https://zhuanlan.zhihu.com/p/56840430" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/56840430</a></p><p>3，<a href="https://baike.baidu.com/item/守护进程/966835?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/966835?fr=aladdin</a></p><p>4，<a href="http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html</a></p><p>5，<a href="https://www.cnblogs.com/tianzhiliang/archive/2011/02/12/1952221.html" target="_blank" rel="noopener">通用守护进程实现</a></p><p>6，[Linux进程组、会话、守护进程](</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;守护进程&quot;&gt;&lt;a href=&quot;#守护进程&quot; class=&quot;headerlink&quot; title=&quot;守护进程&quot;&gt;&lt;/a&gt;守护进程&lt;/h3&gt;&lt;p&gt;守护进程是在后台运行不受终端控制的进程（如输入、输出等），一般的网络服务都是以守护进程的方式运行。守护进程脱离终端的主要原因有两点：&lt;/p&gt;&lt;p&gt;（1）用来启动守护进程的终端在启动守护进程之后，需要执行其他任务。&lt;/p&gt;&lt;p&gt;（2）（如其他用户登录该终端后，以前的守护进程的错误信息不应出现）由终端上的一些键所产生的信号（如中断信号），不应对以前从该终端上启动的任何守护进程造成影响。要注意守护进程与后台运行程序（即加＆启动的程序）的区别。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="后端" scheme="http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>20200305aiops_competition复赛</title>
    <link href="http://yoursite.com/2020/07/05/20200705aiops-competition/"/>
    <id>http://yoursite.com/2020/07/05/20200705aiops-competition/</id>
    <published>2020-07-05T14:34:31.000Z</published>
    <updated>2022-07-13T14:17:15.790Z</updated>
    
    <content type="html"><![CDATA[<h3 id="aiops比赛消费kafka数据"><a href="#aiops比赛消费kafka数据" class="headerlink" title="aiops比赛消费kafka数据"></a>aiops比赛消费kafka数据</h3><p>1，在自己电脑上用终端远程登录服务器： ssh user@ip</p><p>2，输入docker image 查看镜像情况：</p><p>3，启动docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it aiops_0705 /bin/bash</span><br></pre></td></tr></table></figure><p>4，Python执行consumer.py ，consumer.py的kafka的数据怎么取的：对于平台指标和业务指标，解析后的data的主要内容为从指标类型到数据列表的字典；对于调用链数据，则只有一条调用链数据。对data的访问就是对python中dict的访问。</p><a id="more"></a><p>如下：打印的数据就是kafka的实时数据了，可以实时获取到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前面class部分，PlatformIndex(item)，BusinessIndex(item)， Trace(data)见Reference的github</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"><span class="string">'''Consume data and react'''</span></span><br><span class="line"><span class="comment"># Check authorities</span></span><br><span class="line"><span class="keyword">assert</span> AVAILABLE_TOPICS &lt;= CONSUMER.topics(), <span class="string">'Please contact admin'</span></span><br><span class="line"></span><br><span class="line">submit([[<span class="string">'docker_003'</span>, <span class="string">'container_cpu_used'</span>]])</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> message <span class="keyword">in</span> CONSUMER:</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line">data = json.loads(message.value.decode(<span class="string">'utf8'</span>))</span><br><span class="line"><span class="keyword">if</span> message.topic == <span class="string">'platform-index'</span>:</span><br><span class="line"><span class="comment"># data['body'].keys() is supposed to be</span></span><br><span class="line"><span class="comment"># ['os_linux', 'db_oracle_11g', 'mw_redis', 'mw_activemq',</span></span><br><span class="line"><span class="comment">#  'dcos_container', 'dcos_docker']</span></span><br><span class="line">data = &#123;</span><br><span class="line"><span class="string">'timestamp'</span>: data[<span class="string">'timestamp'</span>],</span><br><span class="line"><span class="string">'body'</span>: &#123;</span><br><span class="line">stack: [PlatformIndex(item) <span class="keyword">for</span> item <span class="keyword">in</span> data[<span class="string">'body'</span>][stack]]</span><br><span class="line"><span class="keyword">for</span> stack <span class="keyword">in</span> data[<span class="string">'body'</span>]</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">timestamp = data[<span class="string">'timestamp'</span>]</span><br><span class="line"><span class="keyword">for</span> stack <span class="keyword">in</span> data[<span class="string">'body'</span>]:</span><br><span class="line">print(i, message.topic, timestamp, stack)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> data[<span class="string">'body'</span>][stack]:</span><br><span class="line"><span class="comment"># like class</span></span><br><span class="line"><span class="keyword">print</span> (item.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> message.topic == <span class="string">'business-index'</span>:</span><br><span class="line"><span class="comment"># data['body'].keys() is supposed to be ['esb', ]</span></span><br><span class="line">data = &#123;</span><br><span class="line"><span class="string">'startTime'</span>: data[<span class="string">'startTime'</span>],</span><br><span class="line"><span class="string">'body'</span>: &#123;</span><br><span class="line">key: [BusinessIndex(item) <span class="keyword">for</span> item <span class="keyword">in</span> data[<span class="string">'body'</span>][key]]</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> data[<span class="string">'body'</span>]</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">timestamp = data[<span class="string">'startTime'</span>]</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> data[<span class="string">'body'</span>]:</span><br><span class="line"><span class="keyword">print</span> (i, message.topic, timestamp, key)</span><br><span class="line"><span class="comment"># data['body'][key] is a class</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> data[<span class="string">'body'</span>][key]:</span><br><span class="line"><span class="keyword">print</span> (item.service_name)</span><br><span class="line"><span class="keyword">else</span>:  <span class="comment"># message.topic == 'trace'</span></span><br><span class="line">data = &#123;</span><br><span class="line"><span class="string">'startTime'</span>: data[<span class="string">'startTime'</span>],</span><br><span class="line"><span class="string">'body'</span>: Trace(data),</span><br><span class="line">&#125;</span><br><span class="line">timestamp = data[<span class="string">'startTime'</span>]</span><br><span class="line"><span class="comment"># one data</span></span><br><span class="line">print(i, message.topic, timestamp, data[<span class="string">'body'</span>].pid)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，<a href="https://github.com/NetManAIOps/aiops2020-judge/tree/master/final" target="_blank" rel="noopener">https://github.com/NetManAIOps/aiops2020-judge/tree/master/final</a></p><p>2，<a href="https://zhuanlan.zhihu.com/p/68052232" target="_blank" rel="noopener">kafka原理</a></p><p>3，<a href="https://www.runoob.com/docker/docker-dockerfile.html" target="_blank" rel="noopener">dockerfile的使用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;aiops比赛消费kafka数据&quot;&gt;&lt;a href=&quot;#aiops比赛消费kafka数据&quot; class=&quot;headerlink&quot; title=&quot;aiops比赛消费kafka数据&quot;&gt;&lt;/a&gt;aiops比赛消费kafka数据&lt;/h3&gt;&lt;p&gt;1，在自己电脑上用终端远程登录服务器： ssh user@ip&lt;/p&gt;&lt;p&gt;2，输入docker image 查看镜像情况：&lt;/p&gt;&lt;p&gt;3，启动docker&lt;/p&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker run -it aiops_0705 /bin/bash&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;4，Python执行consumer.py ，consumer.py的kafka的数据怎么取的：对于平台指标和业务指标，解析后的data的主要内容为从指标类型到数据列表的字典；对于调用链数据，则只有一条调用链数据。对data的访问就是对python中dict的访问。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AIOps" scheme="http://yoursite.com/categories/AIOps/"/>
    
    
      <category term="AIOps" scheme="http://yoursite.com/tags/AIOps/"/>
    
      <category term="论文" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87/"/>
    
      <category term="AnomalyDetection" scheme="http://yoursite.com/tags/AnomalyDetection/"/>
    
  </entry>
  
  <entry>
    <title>高级最优化1——线性规划</title>
    <link href="http://yoursite.com/2020/04/21/20200421%E9%AB%98%E7%BA%A7%E6%9C%80%E4%BC%98%E5%8C%961%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2020/04/21/20200421%E9%AB%98%E7%BA%A7%E6%9C%80%E4%BC%98%E5%8C%961%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</id>
    <published>2020-04-21T10:11:17.000Z</published>
    <updated>2022-07-13T14:17:15.787Z</updated>
    
    <content type="html"><![CDATA[<h3 id="高级最优化"><a href="#高级最优化" class="headerlink" title="高级最优化"></a>高级最优化</h3><p>先修条件：线性代数，最优化/运筹，基础的概率论，MATLAB使用（如何建模与使用）</p><h4 id="优化分类"><a href="#优化分类" class="headerlink" title="优化分类"></a>优化分类</h4><p>1，确定性优化：</p><p>Linear Optimization线性规划，Second order cone programming 二阶椎优化，Semidefinite programming （SDP半定优化）</p><a id="more"></a><p>以上三个优化就是现代凸优化。延伸的一些最新的优化：</p><p>Sparse and low rank Optimization（稀疏优化/低秩优化，图像视频处理用的多）</p><p>2，不确定优化：</p><p>stochastic programming（随机优化）：不确定的东西，我们假设分布函数已知，则可以用。</p><p>classical Robust Optimization（鲁棒优化）：测量一个值，一般有误差项 ，这个误差项属于某个范围之内 $\xi \sim\lceil a, b\rceil$，但不知道分布的话，可以用鲁棒优化来建模。</p><p>Distributionally robust Optimization：鲁棒优化和随机优化结合起来，知道分布的部分信息但又不完全知道。比如，$\xi \sim F \in \{Set\}$ Set是一个大的分布族，$E(\xi) = \mu , D(\xi) = \sigma^2$ </p><p>本文主要涉及连续优化和不确定性优化。</p><h4 id="五步法建模"><a href="#五步法建模" class="headerlink" title="五步法建模"></a>五步法建模</h4><p>1，认清楚问题，理解现实问题为数学问题（弄清楚问题！！！最难）</p><p>2，建立优化模型（一般是决策问题）三要素——Decision，constrain，objective function  （如设施选址，决策变量是选地方，约束条件，为了什么（医院覆盖范围广，减少成本等等））</p><p>3，Feed data to model ：模型里有很多参数，从数据里得到参数。大数据时代应用多，Analytics 含statistic + ml ，用data做一些prediction  ，加上优化的模型 （data to decision，数据驱动的决策，数据与运筹相结合）</p><p>4，求解模型</p><p>5，implement the solution：如果不好则返回到步骤1循环看怎么重新建模</p><h3 id="优化模型"><a href="#优化模型" class="headerlink" title="优化模型"></a>优化模型</h3><h4 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h4><p>线性规划常用于生产计划问题，如何安排生产，使得利润最大化。模型解法是Simplex 单纯性方法（ from Dantzig）</p><p>线性规划的标准形式：</p><script type="math/tex; mode=display">min \boldsymbol{c}^{\prime} \boldsymbol{x}</script><script type="math/tex; mode=display">\boldsymbol{A} \boldsymbol{x}=\boldsymbol{b}</script><script type="math/tex; mode=display">x \geq 0</script><h4 id="分片线性"><a href="#分片线性" class="headerlink" title="分片线性"></a>分片线性</h4><p>线性规划可以扩展出很多模型的，如convex piece-wise linear objective function 凸 分片线性的：</p><script type="math/tex; mode=display">\min f(x)=\max _{k}\left(d_{k}^{\prime} x+c_{k}\right)</script><script type="math/tex; mode=display">\text { s.t. } \quad A x \geq b</script><p><img src="/images/20200421Piece_wiseLinearRegression.jpg" alt="20200421Piece_wiseLinearRegression"></p><p>圈1，圈2，圈3分布是在x取不同值时，取最大值时的情况。再看约束，也是线性的，但目标是分段线性的了。任何一个分片线性模型就是类似这种，线性函数中取最大的形式。</p><p>我们改写上面的模型：</p><script type="math/tex; mode=display">min z</script><script type="math/tex; mode=display">s.t. Ax \geq b</script><script type="math/tex; mode=display">\boldsymbol{d}_{k}^{\prime} \boldsymbol{x}+c_{k} \leq z</script><h4 id="绝对值问题"><a href="#绝对值问题" class="headerlink" title="绝对值问题"></a>绝对值问题</h4><p>绝对数的模型，也可以转换为线性规划求解。</p><script type="math/tex; mode=display">min \sum_{j} c_{j}\left|x_{j}\right| ,(c_j \geq 0)</script><script type="math/tex; mode=display">\text { s.t. } \quad A x \geq b</script><p>我们这样看，令<script type="math/tex">z_{j}=\left|x_{j}\right| = max\{x_j,-x_j\}</script>，就可以写为如下形式了：</p><script type="math/tex; mode=display">\min \sum_{j} c_{j} z_{j}</script><script type="math/tex; mode=display">s.t. Ax \geq b</script><script type="math/tex; mode=display">x_j \leq z_j</script><script type="math/tex; mode=display">-x_j \leq z_j</script><p>但并非所有非凸问题可以转回为凸问题，并非所有凸问题都可以转为线性规划问题。</p><h3 id="组合拍卖—机制设计"><a href="#组合拍卖—机制设计" class="headerlink" title="组合拍卖—机制设计"></a>组合拍卖—机制设计</h3><h4 id="Market-for-Word-Cup-Winner问题"><a href="#Market-for-Word-Cup-Winner问题" class="headerlink" title="Market for Word Cup Winner问题"></a>Market for Word Cup Winner问题</h4><p>information market：某个地方集中所有的信息aggregate，来做决策设计机制，稳赚不赔。</p><p>世界杯中可以赌球，假设有五个国家有可能在比赛中胜，每个人都可以生成赌球的订单order（就是赌谁赢），选择中只有赌赢了一个就可以赢 $1。引入一个market maker，他做决策接受或拒绝order，怎么做可以不亏钱。</p><div class="table-container"><table><thead><tr><th>Order</th><th>Price: pi_i</th><th>Quantity limit: q_i</th><th>Filed :x_i</th><th>Argentina：a</th><th>Brazil</th><th>Italy</th><th>Germany</th><th>France</th></tr></thead><tbody><tr><td>1</td><td>0.75</td><td>10</td><td>5</td><td>1</td><td>1</td><td>1</td><td></td><td></td></tr><tr><td>2</td><td>0.35</td><td>5</td><td>5</td><td></td><td></td><td></td><td>1</td><td></td></tr><tr><td>3</td><td>0.4</td><td>10</td><td>5</td><td>1</td><td></td><td>1</td><td></td><td>1</td></tr><tr><td>4</td><td>0.95</td><td>10</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td></td></tr><tr><td>5</td><td>0.75</td><td>5</td><td>5</td><td></td><td>1</td><td></td><td>1</td></tr></tbody></table></div><p>（表里：右侧的1表示赌这个国家赢。price是售价，赌得越厉害比如order 2售价相对低一点。Filed表示market maker做的事，你订单虽然买了Quantity这么多，但maker只限制接受Filed这么多的订单。）</p><h4 id="抽象模型"><a href="#抽象模型" class="headerlink" title="抽象模型"></a>抽象模型</h4><p>给定m状态（即只有一个国家赢，互斥的）。</p><p>order是一系列赌的决策（$a_{i1},a_{i2},…a_{im}$）（表里order 1就是（1，1，1，0，0））。</p><p>price limit是参与者愿意对某order所支付的价格 $\pi_i$。</p><p>quantity limit是参与者最多可以买多少份。$q_i$</p><h4 id="建模Linear-Programming"><a href="#建模Linear-Programming" class="headerlink" title="建模Linear Programming"></a>建模Linear Programming</h4><p>Filed：对order i只接受 $x_i$ ，总收入 $\sum_i \pi_i x_i$ ，对于market maker而言，如果jth个team赢了则成本是 $\sum_i a_{ij}x_i$ ，因为1美元 被赢走了嘛，整个最坏情况就是 $\max _{j=1, \ldots, m}\left\{\sum_{i} a_{i j} x_{i}\right\}$ （即某一个国家赢了导致的最大损失）</p><p>写出线性规划模型为：</p><script type="math/tex; mode=display">\max \sum_{i} \pi_{i} x_{i}-\max _{j}\left\{\sum_i a_{i j} x_{i}\right\}</script><script type="math/tex; mode=display">\text { s.t. } \quad 0 \leq x_{i} \leq q_{i} \forall i=1, \dots, n</script><p>第一个公式的 -max 其实等于 $+\min \left\{-\sum_{i} a_{i j} x_{i}\right\}$</p><p>也可以改写成：</p><script type="math/tex; mode=display">\max \sum_{i} \pi_{i} x_{i}-w</script><script type="math/tex; mode=display">\text { s.t. } \quad \sum_{i} a_{i j} x_{i} \leq w \quad \forall j \in S</script><script type="math/tex; mode=display">0 \leq x_{i} \leq q_{i} \quad \forall i \in N</script><p>($\sum_{i} a_{i j} x_{i} \leq w $，对偶变量dual solution：影子价格，代表了资源的价格 )</p><h3 id="建议参考书籍"><a href="#建议参考书籍" class="headerlink" title="建议参考书籍"></a>建议参考书籍</h3><p>–<a href="http://www.stanford.edu/~boyd/cvxbook/" target="_blank" rel="noopener">Convex Optimization</a>, </p><p>•S. Boyd and L. Vandenberghe.</p><p>–Lecture on modern convex optimization</p><p>•A. Bental and A. Nemirovskii</p><p>–Stochastic Linear Programming</p><p>•P. Kall and J. Mayer</p><p>–Introduction to Stochastic Optimization</p><p>•J. Birge, F. Louveaux</p><p>–Robust Optimization</p><p>•A. Bental, L. El Ghaoui, A. Nemirovskii</p><p>–SHFEU Robust Optimization Course Notes</p><p>•A. Bental</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，陈彩华《高级最优化》</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;高级最优化&quot;&gt;&lt;a href=&quot;#高级最优化&quot; class=&quot;headerlink&quot; title=&quot;高级最优化&quot;&gt;&lt;/a&gt;高级最优化&lt;/h3&gt;&lt;p&gt;先修条件：线性代数，最优化/运筹，基础的概率论，MATLAB使用（如何建模与使用）&lt;/p&gt;&lt;h4 id=&quot;优化分类&quot;&gt;&lt;a href=&quot;#优化分类&quot; class=&quot;headerlink&quot; title=&quot;优化分类&quot;&gt;&lt;/a&gt;优化分类&lt;/h4&gt;&lt;p&gt;1，确定性优化：&lt;/p&gt;&lt;p&gt;Linear Optimization线性规划，Second order cone programming 二阶椎优化，Semidefinite programming （SDP半定优化）&lt;/p&gt;
    
    </summary>
    
    
      <category term="最优化" scheme="http://yoursite.com/categories/%E6%9C%80%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合优化" scheme="http://yoursite.com/tags/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96/"/>
    
      <category term="启发式算法" scheme="http://yoursite.com/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>从优化角度看L1正则化的稀疏性</title>
    <link href="http://yoursite.com/2020/04/18/20200418%E9%AB%98%E7%BA%A7%E6%9C%80%E4%BC%98%E5%8C%96-%E4%BB%8E%E4%BC%98%E5%8C%96%E8%A7%92%E5%BA%A6%E7%9C%8BL1%E6%AD%A3%E5%88%99%E5%8C%96%E7%9A%84%E7%A8%80%E7%96%8F%E6%80%A7/"/>
    <id>http://yoursite.com/2020/04/18/20200418%E9%AB%98%E7%BA%A7%E6%9C%80%E4%BC%98%E5%8C%96-%E4%BB%8E%E4%BC%98%E5%8C%96%E8%A7%92%E5%BA%A6%E7%9C%8BL1%E6%AD%A3%E5%88%99%E5%8C%96%E7%9A%84%E7%A8%80%E7%96%8F%E6%80%A7/</id>
    <published>2020-04-18T14:02:03.000Z</published>
    <updated>2022-07-13T14:17:15.786Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>大数据背景的几个特点：量大large scale，实时性动态产生数据，结构化/半结构化数据，可信赖程度低（Noise，考虑模型如何更robust），高维度且稀疏的数据集。</p><p>这里主要说高维稀疏数据带来的一些问题：</p><p>$x=\left(x_{1}, x_{2}, \cdots, x_{p}\right)$,  特征是p维，数据样例有n个，即整个dataset是 n × p ，传统的统计方法适用于一些 n  &gt; p 的情况，但是当 n &lt;&lt; p的时候，数据量小，但想要求的参数又很多的时候就有困难了。</p><a id="more"></a><h3 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h3><p>从最基本的模型开始来看如何解决这个问题。</p><p>X 代表输入，Y代表输出，$\varepsilon$ 是误差项。</p><script type="math/tex; mode=display">Y=f(X)+\varepsilon</script><p>监督学习，给出数据集 $\left(X_{1}, Y_{1}\right),\left(X_{2}, Y_{2}\right), \ldots,\left(X_{n}, Y_{n}\right)$，如何估计出 $f(X)$ 呢？</p><p>也可以用一些非参数的方法：如用KNN….</p><p>还可以考虑参数方法：施加一些参数进去，我们去估计参数 $\beta_i$</p><script type="math/tex; mode=display">Y=\beta_{1} X^{1}+\beta_{2} X^{2}+\cdots+\beta_{k} X^{p}+\varepsilon=\beta^{T} X</script><p>(这里我们比如我们画图看后，根据领域知识等，假设 f(X) 是线性的等，就用LR模型来看。)</p><p>常用方法用最小二乘法（即最小化平方损失函数）：</p><script type="math/tex; mode=display">\min \sum_{i=1}^{n}\left(Y_{i}-\beta^{T} X_{i}\right)^{2}=\|Y-X \boldsymbol \beta\|^{2}</script><ul><li>这样求解 $\beta$ 会得到很好的统计性质</li><li>问题存在：处理高维数据的时候 $X \in R^{n \times p}$ ，这个问题的解有多个，要取哪个？如果求解的话可以这里可以去写写 $|Y-X \boldsymbol \beta|^{2}$ 的最优性条件 KKT条件有：$X^TX \boldsymbol\beta = X^TY$ ，而这里的 $X^TX$ 是non singular，不可逆，求解有困难。</li><li>可解释性也不太好，这个得到的 $\beta_i$ 一般都是不为0，那Y到底跟哪个X有关呢，怎么找重要的因素去解释呢？</li><li>高维的时候可以考虑降维，如PCA，但也有问题，$x_1,…x_p$ 利用线性组合到一起，把某几个因素合为一个新变量，但新变量的解释也不好说。</li></ul><h3 id="Sparse-Optimization"><a href="#Sparse-Optimization" class="headerlink" title="Sparse Optimization"></a>Sparse Optimization</h3><h4 id="sparse-Optimization"><a href="#sparse-Optimization" class="headerlink" title="sparse Optimization"></a>sparse Optimization</h4><p>考虑用稀疏优化来解决。</p><p>定义稀疏结构 sparse structure：$x \in R^{p}$ 如果仅仅有少部分非0值，则称为sparse vector。</p><p>定义0范式：$||x||_0= \left\{i: x_{i} \neq 0\right\}$ 即是$x_i \neq 0$ 的个数 （如 x = (0,0,1), 则其0范数值为1）</p><p>稀疏数据问题：$||x||_0 &lt;&lt; p$  </p><p>个数限制优化 (Cardinality constrained Optimization)方法：</p><script type="math/tex; mode=display">min \|Y-X \boldsymbol \beta\|^{2}</script><script type="math/tex; mode=display">s.t. \|\boldsymbol \beta\|_{0} \leqslant k \quad(k<< p)</script><p>意思：最小化误差，但有约束存在 $\beta$ 的0范数小于等于 k，只有k个系数不为0，即Y只跟少数的k个X变量有关，解释性就加上了。</p><h4 id="Integer-Programming"><a href="#Integer-Programming" class="headerlink" title="Integer Programming"></a>Integer Programming</h4><p>我们把上面这个优化改写成一个整数规划来看：</p><script type="math/tex; mode=display">\min \|Y-x \beta\|^{2}</script><script type="math/tex; mode=display">s.t. \sum_{i=1}^p S_i \leq k</script><script type="math/tex; mode=display">S_i = 0 \quad or \quad 1</script><script type="math/tex; mode=display">\left|\beta_{i}\right| \leq M S_{i} , M - EnoughBig</script><p>类似一个设施选址问题的写法：两阶段，第一选不选：Si表示选不选，选了变量$X_i$，$S_i$就是1；coefficiency系数，$\beta_i$表示系数。</p><p>这样改写之后，就可以用部分求解器如CVX , Gurobi求解中等规模的问题。但是如果规模太大（ 即 p 非常大）就不好求解了。</p><h4 id="凸近似"><a href="#凸近似" class="headerlink" title="凸近似"></a>凸近似</h4><p>那我们转换整数规划为凸优化来解：</p><p><img src="/images/20200418convex_optimization.jpg" alt="20200418convex_optimization"></p><p>具体来看怎么转换的凸优化呢？</p><p><img src="/images/20200418convexification.jpg" alt="20200418convexification"></p><p>一维情况（左图）：</p><p>我们要去凸近似这个 f(x) 即zero-norm（0范数函数），当x=0时f(x)=0，当x在$-\tau \leqslant x \leqslant \tau$ （这里的$\tau$ 只是表示一个范围，可以取很大，这为了好看）时，f(x) = 1。</p><p>函数图画出来是上面那一根黑线（除开x=0中间那个空点，这个不好处理），怎么去凸近似这个函数呢？我们用函数 g(x) 去近似，即红色那个线把三个点连起来，这是最简单的，也可以考虑用二次函数椭圆形来近似也可以：</p><script type="math/tex; mode=display">g(x) = \frac{|x|}{\tau}</script><p>二维情况（右图）：</p><p>二维的情况也可以画图来分析：就是最下面中心那个点，加上面的十字线除开中间那个点（x其中一个为1），加上最上面为2的面：</p><script type="math/tex; mode=display">f(x) = ||x||_0 = \left\{\begin{array}{ll}0, & \text { If } x=0 \\ 1, & \text { If } x_{1}=0, x_{2} \neq 0 \text { or } \\ & x_{1} \neq 0, x_{2}=0 \\ 2, & \text { If } x_{1} \neq 0, x_{2} \neq 0\end{array}\right.</script><p>这里的凸近似，将下面的四根虚线连起来（延展上去也连上面的四个红点），就是g(x)：</p><script type="math/tex; mode=display">g(x) = \frac{1}{\tau}(\left|x_{1}\right|+\left|x_{2}\right|)</script><p>看看上面一维、二维的情况，都与绝对值有关，是不是还有点像L1正则化的样子，我们接着看。我们总结下zero norm0范式的凸近似是：</p><script type="math/tex; mode=display">\|x\|_{0}:\tau (\|x\|_{1}) = \tau \sum_{i=1}^n |x_i|</script><p>即存在一个 $\tau$ ，使得$\tau (|x|_{1})$ 是$|x|_{0}$最好的凸近似。</p><h3 id="Sparse-Linear-Regression"><a href="#Sparse-Linear-Regression" class="headerlink" title="Sparse Linear Regression"></a>Sparse Linear Regression</h3><h4 id="typical-sparse-model"><a href="#typical-sparse-model" class="headerlink" title="typical sparse model"></a>typical sparse model</h4><p>回忆之前的LR模型：</p><script type="math/tex; mode=display">min \|Y-x \boldsymbol\beta\|^{2}</script><script type="math/tex; mode=display">s.t.:\|\boldsymbol\beta\|_{0} \leqslant k</script><p>这里的约束我们就可以用前面推导的一范数来近似了：</p><script type="math/tex; mode=display">\|\boldsymbol\beta\|_{1} = \sum_{i=1}^p |\beta|_{i} \rightarrow \|\boldsymbol\beta\|_{0}</script><p>上面的模型可以改写为：</p><script type="math/tex; mode=display">min \|Y-x \beta\|^{2}</script><script type="math/tex; mode=display">s.t. \tau\|\beta\|_{1} \leqslant k \quad (即\|\beta\|_{1} \leqslant \lambda)</script><p> 这里的$\lambda$ 自己取。这就产生了新的模型了。</p><p>我们用图形说明看看，sparsity 是真的有的：</p><p><img src="/images/20200419sparsity_model.jpg" alt="20200419sparsity_model"></p><p>左下图：C越大椭圆越大。如果是$|\beta|_{1} \leqslant \lambda$则相交点在坐标轴上，往往是左下图红色点那里，而这个地方则很好的可见 $\beta$ 参数的非0个数  &lt; P=2了。但如果看右边图，采用 $|\beta|_{2}$ 则相交在中间，$\beta$参数的非0个数  =  P（2）了，那$\beta$ 全部都不为0，没有起到稀疏作用。</p><h4 id="Lagrange-version"><a href="#Lagrange-version" class="headerlink" title="Lagrange version"></a>Lagrange version</h4><p>我们再改写下上面的模型为拉格朗日版本，将约束放到上面相当于拉格朗日乘子：</p><script type="math/tex; mode=display">min\|Y-x \beta\|^{2}+{\mu}_{1}\|\beta\|_{0} \rightarrow min \|Y-x \beta\|^{2}+{\mu}_{2}\|\beta\|_{1}</script><p>这里看就是既要看损失，又要看稀疏性，这两者之间有个tradeoff平衡选择。</p><p>右侧这边这个模型，在统计中也叫做lasso模型，也就是L1正则化。</p><p><br></p><p><br></p><p>总结一下，在线性回归中，我们遇到了一个高维的问题导致了参数的不稀疏，无法较好的解释。我们用稀疏优化来解决这个问题，我们把选择部分参数不为0（不为0的参数个数）这个zero norm用凸近似来做，将其转换为绝对值这个凸函数，进过改写为拉格朗日形式后，这个约束就成了L1正则化的形式。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，南京大学，陈彩华 《高级最优化》</p><p>2，《最优化》陈宝林</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;大数据背景的几个特点：量大large scale，实时性动态产生数据，结构化/半结构化数据，可信赖程度低（Noise，考虑模型如何更robust），高维度且稀疏的数据集。&lt;/p&gt;&lt;p&gt;这里主要说高维稀疏数据带来的一些问题：&lt;/p&gt;&lt;p&gt;$x=\left(x_{1}, x_{2}, \cdots, x_{p}\right)$,  特征是p维，数据样例有n个，即整个dataset是 n × p ，传统的统计方法适用于一些 n  &amp;gt; p 的情况，但是当 n &amp;lt;&amp;lt; p的时候，数据量小，但想要求的参数又很多的时候就有困难了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>组合优化问题的启发式算法</title>
    <link href="http://yoursite.com/2020/04/15/20200415%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E7%9A%84%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/04/15/20200415%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E7%9A%84%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-04-15T04:25:01.000Z</published>
    <updated>2022-07-13T14:17:15.786Z</updated>
    
    <content type="html"><![CDATA[<h3 id="组合优化问题"><a href="#组合优化问题" class="headerlink" title="组合优化问题"></a>组合优化问题</h3><h4 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h4><p>车辆路径规划问题，n位客户，在不同地点，有需求。在中央仓库有m辆车辆的均质车队。这是一个NP难问题，这类问题中，启发式和元启发式是实践中最常用的VRP解决方案。</p><p><strong>启发式算法：模拟退火，遗传算法，蚁群优化算法等</strong>。</p><h4 id="NP难问题的一些解决方法"><a href="#NP难问题的一些解决方法" class="headerlink" title="NP难问题的一些解决方法"></a>NP难问题的一些解决方法</h4><p>1，精确方法（枚举，约束编程，分支定界，分支与剪切）是非多项式的，通常可以处理一定规模的问题实例（如旅行商问题TSP的80000节点）。</p><a id="more"></a><p>大量的问题实例可以有效地解决（例如，区间图的顶点着色问题）</p><p>2，一些指数算法仅取决于问题实例的一个参数=&gt;参数化算法（包括伪多项式算法）</p><p>3，近似算法</p><p>4，随机算法</p><p>5，启发式方法和元启发式方法可以视为最后的选择。但他们生成的解决方案没有任何性能保证。</p><h3 id="局部搜索启发式"><a href="#局部搜索启发式" class="headerlink" title="局部搜索启发式"></a>局部搜索启发式</h3><h4 id="局部搜索"><a href="#局部搜索" class="headerlink" title="局部搜索"></a>局部搜索</h4><p>local search局部搜索启发式迭代地优化解。 它枚举了导致新解（称为邻居neighbor）的可能更改（move）的列表，并在改进的情况下应用这些更改（接受更好的解）。</p><p><img src="/images/20200415local_search1.jpg" alt="20200415local_search1"></p><p>仅应用这些邻域会导致问题的局部最优，这可能与最佳解决方案（全局最优）大不相同。需要设计了几种策略来摆脱这些局部最优值，并继续在其他地区进行搜索。</p><h4 id="解决局部最优"><a href="#解决局部最优" class="headerlink" title="解决局部最优"></a>解决局部最优</h4><p>1，允许坏解的运动 deteriorating moves（模拟退火）</p><p>2，在解决方案上施加扰动perturbation以将其移至其他位置</p><p>3，更改邻居（可变邻居搜索<em>variable neighborhood search</em>）</p><p>4，惩罚当前的局部最优值</p><p>5，同时保留多个解（填充），然后将它们交叉在一起以生成新的起点（带有交叉算子的遗传算法）</p><p>6，重复一个建设性的过程来创建新解，并根据先前解中的成功（信息素）来促进良好的建设决策（如蚁群优化/强化学习）。</p><h4 id="metaheuristic定义"><a href="#metaheuristic定义" class="headerlink" title="metaheuristic定义"></a>metaheuristic定义</h4><p>元启发法被正式定义为一种迭代生成过程，该过程通过组合智能的不同概念来探索和利用搜索空间来引导从属启发法，并使用学习策略来构造信息，以便有效地找到接近最优的解决方案</p><p>一些特点：目标是有效地探索搜索空间以找到高质量的解，允许逃出局部最优，方法的抽象级别描述，元启发法通常是不确定的，最近的元启发法会从他们过去的搜索经验中“学习”以指导搜索。</p><h3 id="理论分析"><a href="#理论分析" class="headerlink" title="理论分析"></a>理论分析</h3><h4 id="三种启发式"><a href="#三种启发式" class="headerlink" title="三种启发式"></a>三种启发式</h4><h5 id="Constructive-heuristic"><a href="#Constructive-heuristic" class="headerlink" title="Constructive heuristic"></a>Constructive heuristic</h5><p>1，Constructive heuristic 构造性启发式：将解决方案构造为一系列决策选择，而后无需修改这些选择，一般针对问题量身设计。如今，经常用作更复杂的解决方案方法的子组件，以生成初始解决方案或作为解决方案过程的一部分。</p><p>2，适用场景：</p><p>local search 难的问题。比如，针对不等面积设施布局问题的有偏随机密钥遗传算法，EJOR，2015年。</p><p><img src="/images/20200519BiasedRandom-keyGeneticAlgorithm.jpg" alt="20200519BiasedRandom-keyGeneticAlgorithm"></p><p>用作解决方案解码器 decoder。如，An Exact Approach to the Strip-Packing Problem, INFORMS J. Comput., vol. 15, no. March 2015, pp. 310–319, 2003.</p><p>metaheuristic元启发式的组成部分（GRASP，蚁群优化，破坏再重建方法）。</p><p><img src="/images/20200519StripPacking.jpg" alt="20200519StripPacking"></p><p>3，方法</p><p>贪心算法：每次赋值给一个决策变量，逐步构建出一个解。每一步都选择成本最低的决策。三种贪心策略（TSP1，TSP2，）</p><p><strong>TSP1</strong> : nearest-neighbor heuristic 最近邻居启发式算法。时间复杂度 $O(n^2)$</p><p><img src="/images/20200519TSP.jpg" alt="20200519TSP"></p><p>如图，我们选择离当前点最近的路径。</p><p><strong>TSP2</strong>：cheapest-insertion heuristic 最小代价插入</p><p><img src="/images/20200519TSP2.jpg" alt="20200519TSP2"></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，书籍文章参考</p><p>M. Gendreau and J.-Y. Potvin, Eds., Handbook of Metaheuristics, third edition, 2019.</p><p>E.K. Burke and G. Kendall, Eds., Search Methodologies — Introductory Tutorials in Optimization and Decision Support Techniques. Springer, 2014.</p><p>E.G. Talbi, Metaheuristics: from design to implementation, Wiley Series on Parallel and Distributed Computing, 2009</p><p>C. Blum and A. Roli, “Metaheuristics in Combinatorial Optimization : Overview and Conceptual Comparison,” ACM Comput. Surv., 35(3), 268–308, 2003.</p><p>2，罗志兴，课程</p><p>3，<a href="https://blog.csdn.net/onezeros/article/details/5600094" target="_blank" rel="noopener">TSP路径构造算法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;组合优化问题&quot;&gt;&lt;a href=&quot;#组合优化问题&quot; class=&quot;headerlink&quot; title=&quot;组合优化问题&quot;&gt;&lt;/a&gt;组合优化问题&lt;/h3&gt;&lt;h4 id=&quot;问题引入&quot;&gt;&lt;a href=&quot;#问题引入&quot; class=&quot;headerlink&quot; title=&quot;问题引入&quot;&gt;&lt;/a&gt;问题引入&lt;/h4&gt;&lt;p&gt;车辆路径规划问题，n位客户，在不同地点，有需求。在中央仓库有m辆车辆的均质车队。这是一个NP难问题，这类问题中，启发式和元启发式是实践中最常用的VRP解决方案。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;启发式算法：模拟退火，遗传算法，蚁群优化算法等&lt;/strong&gt;。&lt;/p&gt;&lt;h4 id=&quot;NP难问题的一些解决方法&quot;&gt;&lt;a href=&quot;#NP难问题的一些解决方法&quot; class=&quot;headerlink&quot; title=&quot;NP难问题的一些解决方法&quot;&gt;&lt;/a&gt;NP难问题的一些解决方法&lt;/h4&gt;&lt;p&gt;1，精确方法（枚举，约束编程，分支定界，分支与剪切）是非多项式的，通常可以处理一定规模的问题实例（如旅行商问题TSP的80000节点）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="组合优化" scheme="http://yoursite.com/tags/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96/"/>
    
      <category term="启发式算法" scheme="http://yoursite.com/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="优化算法" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>TreeNode树(PartI遍历)</title>
    <link href="http://yoursite.com/2020/04/15/20200415TreeNode%E6%A0%91(PartI%E9%81%8D%E5%8E%86)/"/>
    <id>http://yoursite.com/2020/04/15/20200415TreeNode%E6%A0%91(PartI%E9%81%8D%E5%8E%86)/</id>
    <published>2020-04-15T00:50:22.000Z</published>
    <updated>2022-07-13T14:17:15.785Z</updated>
    
    <content type="html"><![CDATA[<h3 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h3><p>TreeNode结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x):val(x),left(<span class="literal">NULL</span>),right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p>二叉树：由一个根节点及两颗不相交的二叉树组成。</p><p>满二叉树：每一个结点或者是一个分支结点，并恰好有两个非空的子节点。</p><p>飞空满二叉树的叶结点数等于其分支结点数+1。</p><p>完全二叉树：严格的形状要求，从根节点起每一层从左到右填充。一棵高度为d的完全二叉树，除了d-1层以外，每一层都是满的。（完全二叉树不一定是满二叉树）</p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="普通递归遍历"><a href="#普通递归遍历" class="headerlink" title="普通递归遍历"></a>普通递归遍历</h4><p>前序遍历，中序遍历，后序遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel_preoder0</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;root-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    travel_preoder0(root-&gt;left);</span><br><span class="line">    travel_preoder0(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要返回遍历结果的话，存vector</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; travel_preorder1(TreeNode* root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        travel_preorder1(root-&gt;left);</span><br><span class="line">        travel_preorder1(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用stack辅助前序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travel_preoder2</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; Stk;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        Stk.push(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!Stk.empty()) &#123;</span><br><span class="line">        root = Stk.top();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        Stk.pop();</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            Stk.push(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            Stk.push(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于stack是先入后出，前序遍历的话，root访问之后，先将right右结点放入stack里，再将left左子节点放入stack。但这样写不好写中序遍历和后序遍历的。</p><h4 id="迭代前序遍历算法"><a href="#迭代前序遍历算法" class="headerlink" title="迭代前序遍历算法"></a>迭代前序遍历算法</h4><p>注意节点入stack的顺序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代前序遍历算法，每到一个节点 A，就应该立即访问它。在访问完根节点后，遍历左子树前，要将右子树压入栈。</span></span><br><span class="line"><span class="comment">//时间复杂度为 O(n)</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">    TreeNode* rt = root;</span><br><span class="line">    <span class="keyword">while</span> (rt || stk.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (rt) &#123;</span><br><span class="line">            <span class="comment">//root,left,right</span></span><br><span class="line">            stk.push(rt-&gt;right);</span><br><span class="line">            ans.push_back(rt-&gt;val);<span class="comment">//first root</span></span><br><span class="line">            rt = rt-&gt;left; <span class="comment">// then left</span></span><br><span class="line">        &#125;</span><br><span class="line">        rt = stk.top();<span class="comment">//finally right</span></span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历完整棵树后，结果序列逆序即可。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    TreeNode* rt = root;</span><br><span class="line">    <span class="keyword">while</span>(rt || S.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(rt)&#123;</span><br><span class="line">            <span class="comment">//root,right,left,then reverse</span></span><br><span class="line">            S.push(rt-&gt;left);</span><br><span class="line">            v.push_back(rt-&gt;val);</span><br><span class="line">            rt=rt-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        rt=S.top();</span><br><span class="line">        S.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//inorder 中序迭代遍历树</span></span><br><span class="line"><span class="comment">//每到一个节点 A，因为根的访问在中间，将 A 入栈。然后遍历左子树，接着访问 A，最后遍历右子树。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root)&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    TreeNode* rt = root;</span><br><span class="line">    <span class="keyword">while</span> (rt || S.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (rt) &#123;</span><br><span class="line">            <span class="comment">// all left</span></span><br><span class="line">            S.push(rt);</span><br><span class="line">            rt = rt-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//mid</span></span><br><span class="line">        rt = S.top();</span><br><span class="line">        S.pop();</span><br><span class="line">        v.push_back(rt-&gt;val);</span><br><span class="line">        <span class="comment">//right</span></span><br><span class="line">        rt = rt-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><p>逐层遍历，先根再左边右边逐层访问下来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; DequeTreeNode;</span><br><span class="line">    DequeTreeNode.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!DequeTreeNode.empty()) &#123;</span><br><span class="line">        TreeNode* pNode = DequeTreeNode.front();</span><br><span class="line">        DequeTreeNode.pop();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;pNode-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;left) &#123;</span><br><span class="line">            DequeTreeNode.push(pNode-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;right) &#123;</span><br><span class="line">            DequeTreeNode.push(pNode-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;树结构&quot;&gt;&lt;a href=&quot;#树结构&quot; class=&quot;headerlink&quot; title=&quot;树结构&quot;&gt;&lt;/a&gt;树结构&lt;/h3&gt;&lt;p&gt;TreeNode结构：&lt;/p&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeNode&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TreeNode* left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TreeNode* right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TreeNode(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x):val(x),left(&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;),right(&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;) &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="TreeNode" scheme="http://yoursite.com/tags/TreeNode/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>CauseInfer论文(Part Ⅱ)</title>
    <link href="http://yoursite.com/2020/04/14/20200414CauseInfer%E8%AE%BA%E6%96%872/"/>
    <id>http://yoursite.com/2020/04/14/20200414CauseInfer%E8%AE%BA%E6%96%872/</id>
    <published>2020-04-14T09:29:40.000Z</published>
    <updated>2022-07-13T14:17:15.781Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CauseInfer的系统概述与工作流"><a href="#CauseInfer的系统概述与工作流" class="headerlink" title="CauseInfer的系统概述与工作流"></a>CauseInfer的系统概述与工作流</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>两层因果关系图</strong>：将诊断问题公式化为根因推断问题。为了推断服务和系统指标之间的根本原因，我们将运行中的分布式系统映射到<u>两层分层的因果关系图 two layered hierarchical causality graph。</u> 因果关系图中的每个有向边代表直接的“因果关系”关系。“因果关系cause effect”的合理基础是 原因指标cause metric的变化会导致影响指标effect metric的变化。</p><a id="more"></a><p><strong>较高的层</strong>是<u>由服务依赖关系组成的粗粒度因果关系图</u>，用于将故障原因定位到正确的服务。与NetMedic [15]不同，我们通过分析两个服务之间的通信延迟相关性（traffic lag correlation）来构造服务依赖关系图。</p><p><strong>较低的层</strong>是<u>由系统指标组成的细粒度因果关系图</u>，用于定位到正确的指标。指标因果关系图是通过“因果关系cause effect”概念而不是传统的“相关correlation”概念构建的。</p><p><br></p><h4 id="CauseInfer的工作流workflow"><a href="#CauseInfer的工作流workflow" class="headerlink" title="CauseInfer的工作流workflow"></a>CauseInfer的工作流workflow</h4><p> <strong>CauseInfer的核心模块是因果图生成器和推理引擎。</strong></p><p>因果关系图构建器可以使用收集的系统指标自动构建因果关系图。 </p><p>推论引擎负责推导因果关系图中的真正罪魁祸首。 </p><p>在目标云系统中，每个节点都维护一个指标因果图。 </p><p>推断inference是由前端中的SLO违规触发的，然后沿着服务依赖关系图中的路径从前端服务迭代传递到后端服务。</p><p>如果在一个节点中检测到SLO违规，则根据指标因果关系图进行细粒度的推断。 在本文中，我们将使用第4.1节中描述的统一指标标准<u>TCP请求延迟</u>来表示特定服务的SLO度量标准。</p><p><img src="/images/20200415CauseInfer_pig1.jpg" alt="20200415CauseInfer_pig1"></p><p>CauseInfer的基本结构和工作流程。 最底层是三层系统的物理拓扑。 顶部是抽象的服务和指标因果关系图。 在因果关系图中，大虚线圆圈表示服务，红色节点表示根本原因，黑色节点表示性能指标，绿色节点表示SLO指标，弧线表示因果关系，箭头表示方向 故障传播。</p><p><strong>举例</strong>：我们假设服务II节点中的指标E是根本原因。 当检测到服务I的SLO违反时，将触发原因推断。 在对服务I节点进行原因推断后，我们将性能异常定位于指标A。指标A是服务II的响应时间，它也是服务I指标因果关系图中的根本原因节点。异常A意味着 服务II的SLO被违反。 </p><p>因此，服务II节点中的根因推断被触发，并根据该节点的指标因果关系图继续进行推断。 最后，我们获得了根本原因，度量E。整个推理路径为SLO→A→D→E。</p><p>值得注意的是，由于统计误差和系统噪声，结果可能包含多个度量。 因此，必须有根因排名过程来减少误报并选择最可能的根本原因。</p><p><br></p><p><br></p><h3 id="系统设计——系统模块简介"><a href="#系统设计——系统模块简介" class="headerlink" title="系统设计——系统模块简介"></a>系统设计——系统模块简介</h3><p>如图3所示，CauseInfer系统主要包含两部分，即<strong>离线因果图构建和在线原因推断</strong>。 </p><p>在线部分包含两个模块，即数据收集模块和原因推断模块。 数据收集模块从特定节点中的多个数据源收集实时系统指标，并将<u>数据存储在时间序列数据库</u>中。 当检测到违反SLO时，将触发根因推断模块。 该模块负责根据因果图生成器生成的<u>因果图来精确定位和排序根因</u>。 最后，获得包含最可能原因的原因列表。</p><p> 离线部分包含三个模块，即预处理模块，突变点检测模块和因果图构建模块。 预处理模块在发送到下一阶段之前会对数据进行一些修改。 突变点change point detection检测模块使用贝叶斯change point检测方法将每个预处理指标转换为二进制数据序列。 因果关系图模块利用二值化数据来构建两层分层的因果关系图。 在下文中，我们将详细描述这些模块。</p><p><img src="/images/20200415CauseInfer_fig4.jpg" alt="20200415CauseInfer_fig4"></p><p><br></p><h3 id="系统设计——详述"><a href="#系统设计——详述" class="headerlink" title="系统设计——详述"></a>系统设计——详述</h3><h4 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h4><p><strong>时序数据收集</strong>：我们的目标是确定由根本原因（例如配置错误，过载，资源占用，软件错误等）引起的性能问题的根源。因此，<u>数据收集模块应收集足够多的运行时信息</u>，从应用程序、流程processes到操作系统的不同软件堆栈的多个数据源。当前CauseInfer仅支持数字数据，但不包括非数字数据，例如日志事件，非数字配置项等。</p><p><strong>SLO标准指标TCP时延</strong>：对于基于云或以云为中心的服务，最终用户体验是关键。一个特定应用程序的SLO指标（例如响应时间）可以直接显示最终用户的体验。SLO指标针对不同的应用程序而有所不同。因此，我们提出了一个<u>新的统一SLO度量标准，即TCP请求等待时间（TCP LATENCY）</u>。通过测量通过特定网络端口的最后一个入站数据包（即请求）和第一个出站数据包（即响应）之间的等待时间来获得TCP延迟。尽管此指标很简单，但在我们的系统中效果很好。</p><p><strong>其他指标获取</strong>：对于与流程processes和操作系统相关的指标，我们使用操作系统随附的工具（例如，Linux OS中的/ proc文件系统）收集它们。 除了两个指标标准（即每个进程发送的数据包数量以及内核空间和用户空间的锁lock状态）外，大多数系统度量标准都可以通过这种方式获得。 为了获得前一个指标，我们通过探测与网络传输相关的kprobes [20]（例如netdev.transmit）来捕获信息。 同样，我们通过探测相应的Kprobes来捕获锁定状态。 这些Kprobes已合并到主流Linux操作系统中。</p><p><br></p><h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><p><strong>Data aggregation</strong>：看到一个应用程序生成多个具有相同名称的进程processes来提供服务的情况并不少见。 例如，Apache httpd在Linux操作系统中总是生成多个具有相同名称“ httpd”的进程来处理Web请求。 在这种情况下，我们将这些流程的绩效指标聚合在一起。</p><p><strong>Metric selection</strong>：图4，一些指标高度相关correlation，需要减少冗余指标。</p><p><u>指标选择以简单的成对方式进行</u>：如果两个指标的Pearson相关系数的绝对值超过预设阈值（在本文中为0.8），则将其中一个消除。 例如，在图5中，CPU Int和CPU Irq的相关系数接近1。因此，我们将从CPU Int和CPU Irq中随机选择一个。</p><p> 但是对于那些预定义的根因指标（例如工作量workload和配置项configuration），我们将始终将其保留在指标集中。</p><p><br></p><p><br></p><p><br></p><h4 id="构建算法"><a href="#构建算法" class="headerlink" title="构建算法"></a>构建算法</h4><h5 id="离线change-point-detection"><a href="#离线change-point-detection" class="headerlink" title="离线change point detection"></a>离线change point detection</h5><p>cause-effect定义：如果一个变量变化导致另一个变量变化，则这俩者有因果关系。</p><p>首先识别系统指标里的changes突变。这可以被认为是离线分割问题。 但是挑战在于细分的数量，每个细分中的统计特征（即均值或方差）事先未知。  我们介绍了一种<strong>基于贝叶斯理论的新颖方法，即贝叶斯变化点检测</strong>（BCP）[22]。 变更点检测过程不仅提取变更，而且以二进制格式统一不同尺度的不同系统的指标，这意味着度量数据仅包含“ 0”（未更改）和“ 1”（更改）。</p><p>BCP的基本思想**（paper的P5）：是找到一个参数的基本序列，该序列将时间序列划分为具有相等参数值的连续块（序列块），并定位突变点的位置，即每个块的开始。</p><p>给定块和参数，不同块中的观测值是相互独立的。 应该给每个块的突变点和参数一个先验的概率分布 $\mu_{i,j}$ （是在位置i+1开始在j结束的块的均值）服从 $N\left(\mu_{0}, \sigma_{2}^{0} /(j-i)\right)$</p><p>给定观测序列：$X=\left(x_{1}, x_{2}, \cdots, x_{n}\right)$ ，目标是找到划分 $\rho=\left(P_{1}, P_{2}, P_{3}, \cdots, P_{n-1}\right)$ ，如果$P_i = 1$ ，则表示位置i+1有一个变化change。$\theta_i$ 表示$x_i$所在的划分P的统计参数。</p><p>Barry报告，参数序列$\theta_i$ 形成一个<strong>马尔可夫链</strong>：以概率$ 1 -p_i$ 假设 $\theta_i = \theta_{i+1}$ ，即$x_i,x_{i+1}$ 是属于相同的划分 ，or或者说以概率 $p_i$ 存在一个条件密度 $f\left(\theta_{i+1} | \theta_{i}\right)$ 。因此，我们使用一个马尔可夫蒙特卡洛法来计算一个近似划分。</p><p>在马尔可夫链的每一层转移，根据观测值的序列和 $P_j$ 的当前值，从$P_i$的条件分布中获得 $P_i$ 的值 ，$j \neq i$。在迭代的开始，我们为所有i都初始化 $P_i = 0$ 。转移概率 $p_i$ ，对于位置 $i+1$ 处的突变点的条件概率可以通过以下公式估计（参考论文22，这些表达式的参数设置）：</p><script type="math/tex; mode=display">\frac{p_{i}}{1-p_{i}}=\frac{\left(P_{i}=1 | X, P_{j}, j \neq i\right)}{\left(P_{i}=0 | X, P_{j}, j \neq i\right)}</script><p>因此我们可以获得 $f\left(P_{i}=1 | X, P_{j}, j \neq i\right)$ 和 随机采样$P_i$ 。在一次MCMC迭代中，为每个$P_{i}(1 \leq i \leq n)$ 产生一个值。每次迭代，后验均值$\mu_{i, j}$ 将根据当前划分进行更新。M次迭代以后，我们利用 $\mu_{i, j}$ 的M个估计的平均值作为给定X的后验均值的近似值。类似地，在给定$X$的情况下，我们可以获得$\sigma^2$的后验估计。同时，获得了概率$p_i$。 本文，M设置为1000足以估计参数。 最后，选择具有高概率 $p_i$ 的突变点（例如，本文中pi&gt; 0.6）作为变化。</p><p>为了评估BCP的有效性，我们利用它来确定从第4节中描述的CPU故障注入实验获得的CPU TOTAL指标的更改点。我们通过手动调查确认在CPU TOTAL度量标准中嵌入了16个更改点。  图5（a）显示了在注入多个CPU hog故障以及BCP检测到更改点时的CPU利用率数据。 从该图可以看出，几乎所有的变化都发生在CPU hot fault期间。 图5（b）表明，在CPU出现hog故障期间发生变化的可能性非常高，远大于0.6。 因此，BCP方法可以有效地识别嵌入在数据序列中的更改。 但是，由于BCP需要较长的历史数据和计算复杂性，因此利用BCP实时检测实时变化并不容易。</p><p><br></p><h5 id="随机图的构建-Causality-graph-building"><a href="#随机图的构建-Causality-graph-building" class="headerlink" title="随机图的构建 Causality graph building"></a>随机图的构建 Causality graph building</h5><p>$X \rightarrow Y$ X直接影响Y，表示为$X \in p a(Y)$ ，不允许两个变量相互影响。 因此，所有因果关系都可以通过有向无环图（DAG）进行编码。在DAG中，节点代表特定变量，边代表因果关系。 我们依靠观察和假设来形成因果关系理论。 </p><h6 id="Service-Dependency-Graph"><a href="#Service-Dependency-Graph" class="headerlink" title="Service Dependency Graph"></a>Service Dependency Graph</h6><p><strong>流量关联方法</strong>是一种通用的轻量级方法，无需更改源代码或准备其他知识。基本思想是两个相关服务之间的流量延迟通常表现出“典型”峰值，反映了使用或提供这些服务之间的潜在延迟。 a，我们的方法仅关注使用<strong>TCP</strong>作为其底层传输协议的有限应用程序集，尽管可以很容易地对其进行扩展。 b， 我们的方法依赖于现代操作系统的新属性，例如网络统计工具和用于探测系统调用的内核探测器。 C，我们利用流量延迟来确定依赖方向，而不是确定依赖结构。</p><p>我们使用<strong>两元组（ip，服务名称）</strong>而不是三元组（ip，端口，协议）来标识服务。在分布式系统中，ip表示唯一的主机，服务名称表示在主机中运行的唯一服务。 我们遵循Orion系统中服务依赖项的定义，即如果服务A需要服务B来满足其客户端A→B的某些请求。例如，Web服务需要从数据库服务维护的数据库中获取内容，因此 我们说Web服务取决于数据库服务。 </p><p>该方法开始于使用连接信息来构造服务依赖图的框架。 借助一些现成的网络监控工具（例如netstat），<u>我们获得了所有服务连接信息的列表</u>，包括协议，源IP，目标IP，端口和连接状态（例如，侦听或已建立）。 然后，我们从一堆由TCP协议标记的实时连接中筛选出源和目标信息。 图6展示了一个节点中选定的连接对样本。 每个连接的格式为 source ip : port → destination ip : port, which is called a <em>channel</em>称为通道。 该通道非常接近服务依赖关系，但缺服务的名称。</p><p>进程ID（即PID）。然后，我们将与PID有关的命令行用作服务名称。</p><p><u>通过网络发现两个通信服务之间的服务依赖关系</u>：为了获得特定服务的发送流量，我们通过探测内核函数netdev.transmit来计数数据包的数量，该函数在网络设备要发送缓冲区内容时调用。 假设X表示服务A的发送流量，Y表示服务B的发送流量，则X和Y之间的滞后相关性lag correlation定义为：</p><script type="math/tex; mode=display">\rho_{X Y}(k)=\frac{\sum_{t=0}^{N-1}\left(Y_{t}-\bar{Y}\right)\left(X_{t-k}-\bar{X}\right)}{\sqrt{\sum_{t=0}^{N-1}\left(X_{t}-\bar{X}\right)^{2} \sum_{t=0}^{N-1}\left(Y_{t}-\bar{Y}\right)^{2}}} k \in</script><script type="math/tex; mode=display">k^{*}=\left\{\operatorname{argmax}\left(\left|\rho_{X Y}(k)\right|\right), k \in[-30,30]\right\}</script><p>if $k^{*}&gt;0 , A \rightarrow B$ </p><p><img src="/images/20200417CauseInfer_fig7.png" alt="20200417CauseInfer_fig7"></p><p>由于资源共享，服务可能依赖于在同一节点中运行的其他服务，这被称为“非通信服务依赖性”。 考虑到这种间接依赖性，我们假设其他服务的性能指标的变化也影响当前关注的服务的性能指标的变化。 我们在指标因果关系图中建模这些依赖关系，在以下部分中进行了说明。</p><h6 id="Metric-Causality-Graph"><a href="#Metric-Causality-Graph" class="headerlink" title="Metric Causality Graph"></a>Metric Causality Graph</h6><p>我们<u>利用条件独立性检验</u>[ 参考 26]而非成对相关 pair-wise correlation 来构建因果关系图。 基于“因果关系cause effect”概念构建因果关系图的方法主要有两种，即条件独立性测试和基于评分score based的方法。 考虑到系统指标的高维性和轻量级需求，我们基于PC算法（unsupervised leaning）设计算法。 </p><p>DAG 有向无环图。两假设：causal Markov condition and faithfulness （31）</p><p>作为区分因果关系和相关性的基本属性，<u>因果马尔可夫条件</u>用于在两个以上变量之间产生一组独立关系，并构造因果图的框架。</p><p>忠实性假设指出存在一个有向无环图，G，使得V中变量之间的独立关系正是通过<u>条件马尔可夫条件</u>并由G表示的[26]。 因果关系可以通过因果马尔可夫条件与忠诚条件相结合来发现。</p><p>在这两个假设下，<u>PC算法根据统计条件独立性检验[26] [31]和D-separation [26] [31]为集体变量构造一个DAG</u>。 在本文中，我们利用基于<u>条件交叉熵的度量$G^2$</u> [31]定性地测试给定 $Z$ 时 $X$ 是否依赖于 $Y$，其中X，Y和Z是V中不相交的变量集，X和Y是单变量，但是 Z可以是一组变量。</p><script type="math/tex; mode=display">\begin{aligned} G^{2} &=2 m C E(X, Y | \mathbf{Z}) \\ &=\sum_{z} P(z) \sum_{x} \sum_{y} P(x, y | z) \log \left(\frac{P(x, y | z)}{p(x | z) \cdot p(y | z)}\right) \end{aligned}</script><p>m: sample size</p><p>$C E(X, Y | \mathbf{Z})$ the conditional cross entropy of X and Y given <strong>Z</strong>.</p><p>度量$G^2$服从$\chi^{2}$ ，自由度是：$\left(N_{X}-1\right)\left(N_{Y}-1\right) \prod_{Z^{\prime} \in \mathbf{Z}} N_{Z^{\prime}}$</p><p>$N_{X}, N_{Y} ,N_{Z^{\prime}}$ 各自代表变量 $X ,Y, Z’$ 的值。卡方测试我们可以决定是否接受独立性假设。$p &gt; \xi$ 接受独立性假设。</p><p>给定 $Z$ 如果 $X$ 独立于 $Y$ ，则 $I(X, Y | \mathbf{Z})=1$</p><p>PC算法从完全连接的无向图开始，然后促进 $G^2$ 以成对方式捕获所有变量中的所有独立关系，即该DAG的骨架。 以下工作是使用D-separation[26]，[32]确定因果关系的方向。</p><p><strong>确定因果关系的方向</strong>：</p><p>我们首先为aggressive（没有先验知识）算法准备系统指标。对于没有任何依赖服务的服务（例如数据库服务），因果关系图仅使用本地系统指标来构建。</p><p>但是对于具有依赖服务（例如Web服务）的因果关系图，不仅使用本地系统度量标准，而且还使用其依赖服务的TCP LATENCY度量标准来构建。</p><p>为了诊断由共置co-located服务引起的性能问题，我们将其系统指标集成到此算法中。本文中训练数据的长度设置为200，因为200个数据点足以建立精确的因果图。</p><p>然后，我们<u>采用PC algorithm构建DAG</u>。由于缺乏证据，统计错误或非因果关系，获得的DAG可能包含多个孤立的子图，违反直觉的因果关系和双向链接。例如，在图8（a）中，M5是隔离的，因果关系M 4→M 2是反直觉的，并且M 1和M 4之间的因果关系是双向的。</p><p>为了从SLO指标推断出根本原因，我们进一步使用以下规则从DAG中选择一个最大子图。规则1：作为最终effect metric的本地服务的TCP LATENCY指标没有后代。</p><p>规则2：最终指标可从图中的任何路径可达。</p><p>规则3：对于双向链接，两个方向均被保留，这意味着两个指标标准可能在彼此之间引起影响。</p><p><img src="/images/20200417fig8a.png" alt="20200417fig8a"></p><p><em>aggressive</em> algorithm in Algorithm 1 伪代码（见paper）：</p><p>step1，设置i=0，即$z=\{\}$ ，选择两个指标用 $G^2$ 方法测试他们的独立性。如SLO独立于在G2（Fig9）中的文件，即$I(S L O, F i l e)=1$ ，则将它们俩之间的边移出。</p><p>step2：然后当i = 1和i=2时，测试独立性。在G6中，给定Mem，SLO条件独立与GC，即$I(S L O, G C | M e m)=1$ ，因此 $M e m \in S(S L O, G C)$ </p><p>step3:当i=3，停止条件$\left|a d j\left(G^{u}, X\right)\right| \leq i, \forall X$ 满足。最终得到架构图如G7。</p><p>step4：接下来，根据算法中提到的规则确定方向。首先，G8 as $\operatorname{Mem} \notin S(F i l e, G C)$ ，然后“Mem —— SLO” 被 “ Mem ——&gt; SLO”替代。</p><p>最终的causality graph如G9。使用因果图G9，可以查明Hadoop-3382错误的根本原因。 CauseInfer首先使用服务依赖关系图将异常定位在名称节点上，然后在G9中沿路径“ SLO→Mem→File”找到根本原因“ File”。</p><p><img src="/images/20200417CauseInferFig9.jpg" alt="20200417CauseInferFig9"></p><p> 在本文中，我们将ξ设置为0.2以在开销和准确性之间进行权衡。</p><p>保守算法：首先要初始化完全无向图Gu中的某些方向。 TCP LATENCY和其他度量标准之间的链接是直接的。 指向预设根本原因指标和其他指标之间的链接。 第二点是在子图选择过程中添加另一个规则，即规则4，因为先验知识得到了补充。</p><p><br></p><h5 id="在线根因推断"><a href="#在线根因推断" class="headerlink" title="在线根因推断"></a>在线根因推断</h5><p>当在前端检测到SLO违规时，将触发原因推断。 我们首先使用指标因果关系图推断本地服务的根本原因。 如果根本原因位于本地服务的从属服务的SLO度量标准上，则将推理过程传播到远程从属服务。 该过程将反复进行，直到未发现任何违反SLO的情况或未找到相关服务为止。 请注意，图中的推断方向与因果方向相反。</p><p>为了实时检测SLO指标和其他系统指标的异常，我们采用流行的CUSUM [8]。$X(t)=\left\{x_{1}, x_{2}, \cdots, x_{t}\right\}$ 代表X的观测序列，如果在包括新的到达数据后统计属性发生变化，则会发生异常。$x_k$ 是否是突变基于对数似然比检验。</p><p>CUSUM statistic score is updated ：</p><script type="math/tex; mode=display">S(k+1)=\left(S(k)+\ln \frac{P_{1}\left(x_{k}\right)}{P_{0}\left(x_{k}\right)}\right)^{+}</script><script type="math/tex; mode=display">(a)^{+}=a \text { if } a>0 ; \text { else }(a)^{+}=0, S(0)=0</script><p>$P_i(x_k)$ 代表假设$H_i$下$x_k$的概率，相应的决策规则是：given a threshold h, 1 represt change</p><script type="math/tex; mode=display">d_{k}(S(k))=\left\{\begin{array}{ll}0 & \text { if } S(k) \leq h \\ 1 & \text { if } S(k)>h\end{array}\right.</script><p>为了推断特定节点中的根本原因，我们使用深度优先搜索（DFS）方法遍历度量因果关系图。当遍历图中的度量时，我们使用CUSUM来检查它是否异常。如果异常，我们将继续遍历其后代。否则，我们遍历其兄弟姐妹。如果没有任何异常指标的后代或所有后代中都没有违规，则将该指标视为根本原因。</p><p>图8（b）为例，当S LO异常时，我们从度量S LO开始推理过程。然后，我们调查指标M1。如果正常，则遍历其同级之一，即M2。如果M2异常，则是根本原因。 M2的另一个兄弟是M3。如果M3异常，我们将继续检查M2。由于M2异常，因此将M2作为根本原因。最终，尽管M 2和M 3均异常，但我们仅找到一个根本原因M 2。但是，在基于“相关”的方法中可能并非如此。由于存在多种因果路径，因此在某些情况下有可能获得一组潜在的根本原因。因此，有必要对最可能的原因进行排名和选择。在本文中，我们根据<u>其CUSUM得分</u>对根本原因进行排名。 CUSUM得分最高的根本原因将放在原因列表的顶部。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1, Chen P, Qi Y, Hou D. CauseInfer: automated end-to-end performance diagnosis with hierarchical causality graph in cloud environment[J]. IEEE transactions on services computing, 2016, 12(2): 214-230.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CauseInfer的系统概述与工作流&quot;&gt;&lt;a href=&quot;#CauseInfer的系统概述与工作流&quot; class=&quot;headerlink&quot; title=&quot;CauseInfer的系统概述与工作流&quot;&gt;&lt;/a&gt;CauseInfer的系统概述与工作流&lt;/h3&gt;&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;两层因果关系图&lt;/strong&gt;：将诊断问题公式化为根因推断问题。为了推断服务和系统指标之间的根本原因，我们将运行中的分布式系统映射到&lt;u&gt;两层分层的因果关系图 two layered hierarchical causality graph。&lt;/u&gt; 因果关系图中的每个有向边代表直接的“因果关系”关系。“因果关系cause effect”的合理基础是 原因指标cause metric的变化会导致影响指标effect metric的变化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AIOps" scheme="http://yoursite.com/categories/AIOps/"/>
    
    
      <category term="AIOps" scheme="http://yoursite.com/tags/AIOps/"/>
    
      <category term="论文" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87/"/>
    
      <category term="faultDiagnosis" scheme="http://yoursite.com/tags/faultDiagnosis/"/>
    
      <category term="RootCause" scheme="http://yoursite.com/tags/RootCause/"/>
    
  </entry>
  
  <entry>
    <title>CauseInfer论文（partI）</title>
    <link href="http://yoursite.com/2020/04/13/20200413CauseInfer%E8%AE%BA%E6%96%871/"/>
    <id>http://yoursite.com/2020/04/13/20200413CauseInfer%E8%AE%BA%E6%96%871/</id>
    <published>2020-04-13T06:47:37.000Z</published>
    <updated>2022-07-13T14:17:15.780Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ABS-amp-Intro"><a href="#ABS-amp-Intro" class="headerlink" title="ABS &amp; Intro"></a>ABS &amp; Intro</h3><h4 id="云系统背景"><a href="#云系统背景" class="headerlink" title="云系统背景"></a>云系统背景</h4><p><strong>许多组件，复杂交互</strong>：cloud-based and cloud-centric systems always consist of a mass of components running in large distributed environments with complicated interactions.</p><a id="more"></a><h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p><strong>引起性能问题的一些因素</strong>：highly dynamic runtime environment changes (e.g., overload and resource contention竞争，内部损伤) or software bugs (e.g., memory leak 外部)</p><p>必要性：在多租户云平台中，由于多个应用程序在同一位置，资源争用会导致持久的性能下降。在实际的生产系统中，性能问题可能会导致巨大的收入损失。（亚马逊数据）</p><p>定位好处：为系统管理员提供一些见解，例如瓶颈在哪里，或者两个应用程序适合共存于同一台机器上。如果快速找到根本原因，则可以显着降低云应用程序的MTTR。</p><h4 id="细粒度根因定位困难"><a href="#细粒度根因定位困难" class="headerlink" title="细粒度根因定位困难"></a>细粒度根因定位困难</h4><p>困难原因：due to complicated interactions and a large cardinality of potential cause set.</p><h5 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h5><p>监控中心以固定的时间间隔收集性能指标（例如CPU使用率），并在SLO（Service level objective）指标（例如响应时间）超过预设阈值时发出警报。 如果发生警报，系统管理员将始终手动查明罪魁祸首。 但手动诊断可能非常费力费时容易出错。</p><h4 id="本文内容"><a href="#本文内容" class="headerlink" title="本文内容"></a>本文内容</h4><p>构建CauseInfer系统，指出根因原因与给出提示。</p><p>CauseInfer可以自动将分布式系统映射到两层分层的因果关系图，并沿着因果关系图中的因果路径推断根本原因。 CauseInfer以明确的方式对故障传播路径进行建模，并且无需对正在运行的生产系统进行检测即可工作，</p><p>这使得CauseInfer比以前的方法更加有效和实用。 在两个基准系统中的实验评估表明，CauseInfer可以高精度地识别根本原因。 与几种最新方法相比，CauseInfer可以实现10％以上的改进。 此外，CauseInfer轻巧且足够灵活，可以轻松地在大型分布式系统中进行扩展。 使用CauseInfer，可以显着减少云系统的平均恢复时间（MTTR）。</p><h3 id="文献综述"><a href="#文献综述" class="headerlink" title="文献综述"></a>文献综述</h3><h4 id="一些不足"><a href="#一些不足" class="headerlink" title="一些不足"></a>一些不足</h4><h5 id="粗粒度"><a href="#粗粒度" class="headerlink" title="粗粒度"></a>粗粒度</h5><p>一些工作着重于粗略地定位故障（例如，服务级别[5]，[6]或节点级别[7]，[8]，[9]），而不是细粒度地确定真正原因粒度（例如，代码段[10]，[11]，[12]或配置项）。我们认为，粗粒度的故障定位还远远不够，因为它无法为我们提供更多根本原因的详细信息，这使得及时恢复系统变得困难。</p><h5 id="相当大的开销"><a href="#相当大的开销" class="headerlink" title="相当大的开销"></a>相当大的开销</h5><p>为了缩小故障位置，几个系统[10]，[12]，[13]，[14]可以非常精细地确定根本原因。但是他们需要检测应用程序源代码或正在运行的系统，这给生产系统带来了可观的开销。 </p><h5 id="因果关系弱"><a href="#因果关系弱" class="headerlink" title="因果关系弱"></a>因果关系弱</h5><p>大量工作[6]，[7]，[8]，[15]以成对方式利用“相关性correlation”分析来发现服务依赖性或运行时系统度量间的依赖性，并推断出根据这些依赖关系的根本原因。但是，<u>“相关”并不等同于“因果关系”</u>。弱的因果关系可能导致诊断结果不准确。</p><h4 id="OurWork"><a href="#OurWork" class="headerlink" title="OurWork"></a>OurWork</h4><h5 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h5><p>在开销和粒度之间存在冲突时，要在两者之间取得平衡是一项艰巨的工作。细粒度总是意味着高开销。本文提出了一种解决方案，可以在不考虑开销的情况下进行细粒度的诊断。</p><p>性能问题原因大致分为两类：即<u>外部和内部损害</u>。前一类包括资源争用，配置错误，过载，资源消耗等等。后者主要指软件错误。此外，我们的主要观察结果是，大多数此类损害可以通过运行时系统指标直接或间接地表现出来，这将在第2节中更详细地说明。此外，这些指标可以通过现成的工具轻松监控。根据此观察，<u>我们的目标是通过将原因归因于最相关的运行时系统指标来缩小导致性能问题的可能原因。</u>例如，如果系统中发生并发错误，则根本原因应归因于违反的“锁定”指标。</p><h5 id="两关键问题"><a href="#两关键问题" class="headerlink" title="两关键问题"></a>两关键问题</h5><p>i）如何对正在运行的服务和运行时性能指标之间的因果关系进行建模，以及（ii）如何使用具有成本效益的方法来推断根本原因。</p><h5 id="CauseInfer简介"><a href="#CauseInfer简介" class="headerlink" title="CauseInfer简介"></a>CauseInfer简介</h5><p>根因指标的变化会导致effect metric的改变，<u>CauseInfer的本质是建立因果图，该因果图用于为运行分布式系统的故障传播路径建模并在因果图中沿因果路径推断根本原因。</u> 为此，CauseInfer首先从多个数据源收集运行时性能指标，然后通过<strong>贝叶斯变化点检测方法</strong> 提取嵌入在这些指标中的变化点。</p><p>利用变化数据，CauseInfer通过基于统计的方法构造两层层次因果图，以解决关键问题（i）。该因果图由一个粗粒度图和一个细粒度图组成。前一个图是通过一种新颖的轻量级流量滞后相关方法<strong>（traffic lag correlation method）</strong>构造的服务级依赖图，旨在将根本原因定位在服务级别上。而后一个图是系统指标/度量metric因果关系图<strong>（system metric causality graph）</strong>，它是通过条件独立性测试[16]在运行时性能指标中构建的，目的是在指标级别找到真正的罪魁祸首。</p><p>为了解决关键问题（ii），针对每个节点1专门构建指标因果图。应用程序的SLO（Service level objective）指标将来自不同节点的两个指标因果关系图链接在一起。</p><p>CauseInfer部署在基于云的系统中。它着重于诊断导致虚拟服务器中违反SLO的性能问题。 <strong>CauseInfer通过监视服务的响应时间来检测SLO违规</strong>。其他SLO指标（例如，可用性）将在我们的未来工作中进行讨论。（不会影响SLO的性能问题不在本文讨论范围之内。例如，除非服务器的内存使用率很高，否则CauseInfer将不会开始诊断，除非请求响应时间很高。）此外，系统崩溃也不在我们的考虑范围之内，因为可以通过诸如Sherlock [17]之类的传统工具来解决它们。</p><p>一旦发生SLO违规，就会触发推理过程。 CauseInfer首先通过分析特定服务的SLO指标来定位故障。然后，它通过检测因果路径上有故障的节点中的性能指标违规来查明根本原因。重复该过程，直到揭示出所有潜在的根本原因。由于采用了分层图结构，在推理过程中跳过了一些常规路径，因此大大缩短了推理时间。在两个测试基准中的实验评估，即在线事务处理（OLTP）基准：TPC-W [18]和大数据基准：BigDataBench [19]，表明CauseInfer可以准确地找出根本原因，并且胜过几种最先进的方法。</p><h5 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h5><p>1，Bayesian change point 检测方法   </p><p>2，通过分析两个服务之间的通信延迟相关性the traffic lag correlation，提出了一种新颖的轻量级服务依赖发现方法。 服务依赖关系图非常有效地指导我们在服务级别上定位性能问题。</p><p>3，我们设计了一种新颖的方法来发现从多个数据源收集的运行时系统指标之间的因果关系。 与基于correlation-based approaches 相关的方法不同，该方法利用条件独立性测试来精确快速地对系统故障之间的故障传播路径进行建模。</p><p>4，CauseInfer系统</p><h3 id="故障背景与动机"><a href="#故障背景与动机" class="headerlink" title="故障背景与动机"></a>故障背景与动机</h3><h4 id="云平台需要诊断工具"><a href="#云平台需要诊断工具" class="headerlink" title="云平台需要诊断工具"></a>云平台需要诊断工具</h4><p>举例：在Hadoop错误库有一个真正的性能错误，即Hadoop-3382。 未完全关闭打开的文件时，在namenode中发生内存泄漏。 而且内存泄漏将延长Hadoop请求的响应时间。 <u>故障传播路径是“打开的文件→内存利用率→响应时间”</u>。 如果事先知道故障传播路径，则可以查明性能问题的根本原因。 以Hadoop-3382为例，一旦作业执行时间变得异常，我们就可以在“打开的文件”中找到根本原因。 这促使我们对故障传播路径进行显式建模。</p><h4 id="性能问题分类"><a href="#性能问题分类" class="headerlink" title="性能问题分类"></a>性能问题分类</h4><p>引用【7,8,15】，我们发现性能问题可能是由运行时环境更改或软件错误引起的。通过手动分析这些原因，这些原因与 <strong>物理资源（例如，CPU和内存）或逻辑资源（例如，锁和队列）高度相关</strong>，并且可以很容易地监视这两个原因。这一发现也与[11]中的观察结果相符，在该发现中作者声称可以通过 <strong>分析系统调用</strong>（例如sys write，sys open，sys futex等）来诊断性能错误。这些系统调用用于为应用程序提供接口，以利用物理或逻辑系统资源。</p><p><img src="/images/20200414CauseInfer_fig1.jpg" alt="20200414CauseInfer_fig1"></p><p>如图1所示。因此，通过分析物理或逻辑资源利用率，我们可以细粒度地诊断性能问题。</p><h4 id="相关性陷进"><a href="#相关性陷进" class="headerlink" title="相关性陷进"></a>相关性陷进</h4><p>大量现有文献利用“相关性”（例如，皮尔逊相关系数）对服务[5]，[6]或系统指标[2]，[7]，[8]之间的依赖关系进行建模。我们认为基于“相关性”的方法可能会错误地将某些独立关系视为依赖关系的可能性很高。原因是该方法旨在仅捕获两个指标之间的简单关联。它<u>不能捕获两个以上指标之间的更复杂的依赖关系</u>，称为“条件依赖”。</p><p>（CauseInfer论文(Part Ⅱ) CauseInfer的工作流模型）</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1, Chen P, Qi Y, Hou D. CauseInfer: automated end-to-end performance diagnosis with hierarchical causality graph in cloud environment[J]. IEEE transactions on services computing, 2016, 12(2): 214-230.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ABS-amp-Intro&quot;&gt;&lt;a href=&quot;#ABS-amp-Intro&quot; class=&quot;headerlink&quot; title=&quot;ABS &amp;amp; Intro&quot;&gt;&lt;/a&gt;ABS &amp;amp; Intro&lt;/h3&gt;&lt;h4 id=&quot;云系统背景&quot;&gt;&lt;a href=&quot;#云系统背景&quot; class=&quot;headerlink&quot; title=&quot;云系统背景&quot;&gt;&lt;/a&gt;云系统背景&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;许多组件，复杂交互&lt;/strong&gt;：cloud-based and cloud-centric systems always consist of a mass of components running in large distributed environments with complicated interactions.&lt;/p&gt;
    
    </summary>
    
    
      <category term="AIOps" scheme="http://yoursite.com/categories/AIOps/"/>
    
    
      <category term="AIOps" scheme="http://yoursite.com/tags/AIOps/"/>
    
      <category term="论文" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87/"/>
    
      <category term="faultDiagnosis" scheme="http://yoursite.com/tags/faultDiagnosis/"/>
    
      <category term="RootCause" scheme="http://yoursite.com/tags/RootCause/"/>
    
  </entry>
  
  <entry>
    <title>hadoop配置</title>
    <link href="http://yoursite.com/2020/04/06/20200406hadoop%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/04/06/20200406hadoop%E9%85%8D%E7%BD%AE/</id>
    <published>2020-04-06T03:01:16.000Z</published>
    <updated>2022-07-13T14:17:15.779Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SSH远程"><a href="#SSH远程" class="headerlink" title="SSH远程"></a>SSH远程</h3><p>1，在mac上用parallels desktop开启一个Ubuntu16的虚拟机。</p><p>注意设置里换源，中国区的快些。</p><p>然后进行更新 (sudo apt-get update ,  然后sudo apt-get upgrade)</p><p>然后安装ssh（sudo apt-get install openssh-server）。</p><a id="more"></a><p>然后我在本机mac这边用ssh远程登录ubuntu。将mac的ssh公钥发送给ubunt，（ssh-copy-id <em>*</em>@10.211.55…IP），以后就可以直接ssh user@IP登录ubuntu了。</p><h3 id="下载资源"><a href="#下载资源" class="headerlink" title="下载资源"></a>下载资源</h3><h4 id="Java环境"><a href="#Java环境" class="headerlink" title="Java环境"></a>Java环境</h4><p>在 Linux 中下载java JDK，下载的Linux X64的1.7版本的jdk-7u80</p><p><a href="https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html#jdk-7u80-oth-JPR" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/javase7-archive-downloads.html#jdk-7u80-oth-JPR</a></p><p><img src="/images/20200407JavaJDK.jpg" alt="20200407JavaJDK"></p><p>我远程scp传到ubuntu的时候提醒connection refused，这个是因为我mac的setting里的sharing的remote login没有开启，这里得开启一下。</p><p>接着配置Java环境变量，配置在/etc/profile中，作为<strong>全局系统变量</strong>，使用<strong>sudo vi /etc/profile</strong>进行环境变量编辑，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加并保存</span></span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk1.7.0_80  #注意此处jdk目录与你解压目录相同</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>编辑完后终端输入<strong>source /etc/profile</strong>使环境变量生效。</p><h4 id="hadoop下载"><a href="#hadoop下载" class="headerlink" title="hadoop下载"></a>hadoop下载</h4><p>下载的hadoop2.6版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -c --header "Cookie: oraclelicense=accept-securebackup-cookie" http://archive.cloudera.com/cdh5/cdh/5/hadoop-2.6.0-cdh5.7.0.tar.gz</span><br></pre></td></tr></table></figure><p>然后对hadoop进行解压放到与jdk同一个目录中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf hadoop-2.7.1.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure><p>配置hadoop全局环境变量并使其生效，在Java环境变量配置的下面:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">HADOOP VARIABLES</span></span><br><span class="line">export HADOOP_HOME=/usr/local/hadoop-2.6.4</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin</span><br><span class="line">export HADOOP_MAPRED_HOME=$HADOOP_HOME</span><br><span class="line">export HADOOP_COMMON_HOME=$HADOOP_HOME</span><br><span class="line">export HADOOP_HDFS_HOME=$HADOOP_HOME</span><br><span class="line">export YARN_HOME=$HADOOP_HOME</span><br><span class="line">export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native</span><br><span class="line">export HADOOP_OPTS="-Djava.library.path=$HADOOP_HOME/lib"</span><br></pre></td></tr></table></figure><p>编辑完后终端输入<strong>source /etc/profile</strong>使环境变量生效。</p><p>另外这里注意配置hadoop-env.sh文件的$JAVA_HOME，接着用<strong>sudo gedit hadoop-env.sh</strong>配置jdk绝对路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java/jdk1.7.0_80  #注意此处jdk目录与你解压目录相同</span><br></pre></td></tr></table></figure><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h4 id="映射配置"><a href="#映射配置" class="headerlink" title="映射配置"></a>映射配置</h4><p>使用 vim 进入到 “/etc/hostname” 的这个文件进行修改，我修改了为“wangxue-para”，同时修改“/etc/hosts”文件，在里面追加 IP 地址与 wangxue-para 主机的映射。</p><p><img src="/images/20200407hadoop-hostname.jpg" alt="20200407hadoop-hostname"></p><h4 id="配置免秘钥登录"><a href="#配置免秘钥登录" class="headerlink" title="配置免秘钥登录"></a>配置免秘钥登录</h4><p>整个hadoop的处理过程之中，都是利用ssh实现通讯的，就算是在本机，也一样使用ssh进行通讯处理，因此需要在电脑上配置ssh免登录处理。</p><p>在本主机上生成一个ssh key：使用<strong>sudo apt-get openssh-server</strong>安装openssh-server后，然后使用<strong>ssh-keygen -t rsa -P “”</strong>生成.ssh文件</p><p>保存公钥：这个时候的程序如果要想进行登录依然需要密码。需要将公钥信息保存在授权认证的文件之中 ： “authorized_key”文件里面。<strong>cd .ssh/</strong>进入到该文件中，然后使用 <strong>ls</strong> 命令查看其中的文件，然后使用<strong>cat id_rsa.pub &gt;&gt; authorized_keys</strong>把公钥存到authorized_keys文件中，最后使用<strong>ssh localhost</strong>验证免密钥是否配置成功。</p><h3 id="Hadoop简介"><a href="#Hadoop简介" class="headerlink" title="Hadoop简介"></a>Hadoop简介</h3><h4 id="Hadoop-主要包含模块"><a href="#Hadoop-主要包含模块" class="headerlink" title="Hadoop 主要包含模块"></a>Hadoop 主要包含模块</h4><ul><li>Hadoop Common: The common utilities that support the other Hadoop modules.</li><li>Hadoop Distributed File System (HDFS™): A distributed file system that provides high-throughput access to application data.</li><li>Hadoop YARN: A framework for job scheduling and cluster resource management.</li><li>Hadoop MapReduce: A YARN-based system for parallel processing of large data sets.</li></ul><p>hadoop支持三种启动模式：</p><ul><li>Local (Standalone) Mode - 单机模式</li><li>Pseudo-Distributed Mode - 伪分布式</li><li>Fully-Distributed Mode - 全分布式</li></ul><h4 id="wordcount单机测试"><a href="#wordcount单机测试" class="headerlink" title="wordcount单机测试"></a>wordcount单机测试</h4><p>在单机模式下，读取的是本地数据，这里采用的是单机模式。</p><p>进入你的/hadoop目录我的是“~/app/hadoop2.6”，使用<strong>mkdir input</strong>创建一个input文件夹。随便在input目录下创建一个txt文本，准备统计文本的单词个数。</p><p>执行hadoop的统计命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar share/hadoop/mapreduce/sources/hadoop-mapreduce-examples-2.6.0-cdh5.7.0-sources.jar org.apache.hadoop.examples.WordCount input output</span><br></pre></td></tr></table></figure><p>进行对单词的计数测试，然后再使用<strong>cat output/*</strong>查看计数的结果。</p><p><img src="/images/20200407single_wordcount.jpg" alt="20200407single_wordcount"></p><h4 id="伪分布式"><a href="#伪分布式" class="headerlink" title="伪分布式"></a>伪分布式</h4><p>伪分布式读取的则是 HDFS 上的数据；要使用 HDFS，首先需要在 HDFS 中创建用户目录。</p><p>伪分布式里要修改hadoop的几个重要的文件。先做简单的介绍：</p><h5 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h5><p>配置公共属性，指定namenode标识以及其端口号。即确定Hadoop的核心的信息，包括临时目录，访问地址。我们用gedit编辑它。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd hadoop/etc/hadoop/</span><br><span class="line">vim core-site.xml</span><br></pre></td></tr></table></figure><p>在configuration中添加配置property：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;file:/home/wangxue/app/hadoop-2.6/tmp&lt;/value&gt;</span><br><span class="line">        &lt;description&gt;location to store temporary files&lt;/description&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>这个文件路径配置的是临时文件的地址，不配置就会在hadoop的文件夹里面生成“tmp”文件(“/home/wangxue/app/hadoop-2.6/tmp”)，如果这样配置，每次重新开机启动，所有的配置就会被清空，namenode的格式化信息就会丢失，您的Hadoop环境就失效了。所以这里先建立tmp文件夹，再重新配置一个tmp文件的目录。</p><h5 id="hdfs-site-xml"><a href="#hdfs-site-xml" class="headerlink" title="hdfs-site.xml"></a>hdfs-site.xml</h5><p>可以确定文件的备份个数以及数据文件夹的路径，即指定namenode存放元数据的位置和datanode存放数据块的位置，配置HDFS：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;file:/home/wangxue/app/hadoop-2.6/hdfs/name&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;file:/home/wangxue/app/hadoop-2.6/hdfs/data&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>HDFS文件存储的副本个数，默认3。因为我们这只有一个节点，所以设置1.</p><h5 id="mapred-site-xml"><a href="#mapred-site-xml" class="headerlink" title="mapred-site.xml"></a>mapred-site.xml</h5><p>配置MapReduce，用于指定jobtracker标识及其端口号、指定tasktracker执行mapreduce程序的本地目录和共享目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>采用yarn管理MR，还可以配置：</p><p>apreduce.jobhistory.address 历史服务器端口地址mapreduce.jobhistory.webapp.address 历史服务器web端地址</p><h5 id="yarn-site-xml"><a href="#yarn-site-xml" class="headerlink" title="yarn-site.xml"></a>yarn-site.xml</h5><p>暂时简单的理解为配置相关的job的处理，配置YARN</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt; </span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; </span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt; </span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>最后执行<strong>hdfs namenode –format</strong>命令来格式化hdfs。</p><p><img src="/images/20200410hdfs_format.jpg" alt="20200410hdfs_format"></p><p>然后依次执行hdfs的命令</p><p><strong>sbin/start-dfs.sh，sbin/start-yarn.sh</strong>来启动hadoop。</p><p><img src="/images/20200410start_hdfs.jpg" alt="20200410start_hdfs"></p><p>在终端输入<strong>jps</strong>发现相应的NameNode、DataNode等java进程已经在运行了。</p><p><img src="/images/20200410jsp.jpg" alt="20200410jsp"></p><p>可以打开firefox浏览器，输入网址 <a href="http://localhost:50070，查看NameNode和DataNode相关信息。" target="_blank" rel="noopener">http://localhost:50070，查看NameNode和DataNode相关信息。</a></p><p><img src="/images/20200410web_hdfs.jpg" alt="20200410web_hdfs"></p><p>检查配置是否成功，运行WordCount例子。创建输出文件夹，将txt文本文件放入input下，然后执行wordcount进行统计，最后cat展示output的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bin/hadoop fs -mkdir -p input</span><br><span class="line"></span><br><span class="line">bin/hadoop fs -copyFromLocal README.txt input</span><br><span class="line"></span><br><span class="line">bin/hadoop jar share/hadoop/mapreduce/sources/hadoop-mapreduce-examples-2.7.3-sources.jar org.apache.hadoop.examples.WordCount input output</span><br><span class="line"></span><br><span class="line">bin/hadoop fs -cat output/*</span><br></pre></td></tr></table></figure><h3 id="Python执行任务"><a href="#Python执行任务" class="headerlink" title="Python执行任务"></a>Python执行任务</h3><p>参考4，<a href="https://www.jianshu.com/p/229c7ec48110" target="_blank" rel="noopener">https://www.jianshu.com/p/229c7ec48110</a></p><p>首先我在hadoop-2.6目录下新建文件夹test/code/ ，用于存放mapper.py和reducer.py</p><p>遇到的问题：找不到hadoop-streaming，注意要找到自己本地环境中安装hadoop中的stream jar包，我的也是在share目录下的，用tab补全jar名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/app/hadoop-2.6/share/hadoop/tools/lib/hadoop-streaming-2.6.0-cdh5.7.0.jar</span><br></pre></td></tr></table></figure><p>然后上传本地的txt文件（用于统计单词的原始文本）到hdfs系统。</p><p>这里遇到一个问题是，执行到mapreduce.job: Running job <em>**</em>就一直卡着不动了，这里我停下了，重新jps命令检查了hadoop的启动信息，缺少了NodeManager，故重新启动了下hadoop。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop-all.sh</span><br><span class="line">start-all.sh</span><br></pre></td></tr></table></figure><p>jps结果如下，这个是正常的：</p><p><img src="/images/20200415py_jps.jpg" alt="20200415py_jps"></p><p>然后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/hadoop jar /share/hadoop/tools/lib/hadoop-streaming-2.6.0-cdh5.7.0.jar -file /test/code/mapper.py    -mapper /test/code/mapper.py -file /test/code/reducer.py   -reducer /home/hadoop/reducer.py -input /user/wangxue/hdfs_first/* -output /user/wangxue/hdfs_first_output</span><br></pre></td></tr></table></figure><p>正确执行：</p><p><img src="/images/20200415py_wordcount.jpg" alt="20200415py_wordcount"></p><p>最后用cat命令查看结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/hdfs dfs -cat /user/wangxue/hdfs_first_output/part-00000</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，部分参考 <a href="http://blog.sanyuehua.net/2017/10/30/Hadoop-Pseudo-distributed/" target="_blank" rel="noopener">http://blog.sanyuehua.net/2017/10/30/Hadoop-Pseudo-distributed/</a></p><p><a href="https://blog.sanyuehua.net/2017/10/27/Hadoop-SetUp/" target="_blank" rel="noopener">https://blog.sanyuehua.net/2017/10/27/Hadoop-SetUp/</a></p><p>2，<a href="https://zhengbao.wang/Centos7搭建Hadoop伪分布式集群详细步骤/" target="_blank" rel="noopener">https://zhengbao.wang/Centos7%E6%90%AD%E5%BB%BAHadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/</a></p><p>3，《云计算课程》实验2</p><p>4，<a href="https://www.jianshu.com/p/229c7ec48110" target="_blank" rel="noopener">https://www.jianshu.com/p/229c7ec48110</a> 让Python代码在hadoop上运行</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;SSH远程&quot;&gt;&lt;a href=&quot;#SSH远程&quot; class=&quot;headerlink&quot; title=&quot;SSH远程&quot;&gt;&lt;/a&gt;SSH远程&lt;/h3&gt;&lt;p&gt;1，在mac上用parallels desktop开启一个Ubuntu16的虚拟机。&lt;/p&gt;&lt;p&gt;注意设置里换源，中国区的快些。&lt;/p&gt;&lt;p&gt;然后进行更新 (sudo apt-get update ,  然后sudo apt-get upgrade)&lt;/p&gt;&lt;p&gt;然后安装ssh（sudo apt-get install openssh-server）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据挖掘" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="配置" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>大数据技术1hadoop</title>
    <link href="http://yoursite.com/2020/04/05/20200405%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF1hadoop/"/>
    <id>http://yoursite.com/2020/04/05/20200405%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF1hadoop/</id>
    <published>2020-04-05T01:37:46.000Z</published>
    <updated>2022-07-13T14:17:15.779Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h3 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h3><h3 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h3><p>hadoop是一个开源框架，允许使用简单的编程模型在跨计算机集群的分布式环境中存储和处理大数据。</p><h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><p>分布式文件系统，是一个高度容错性的系统（每个数据块都复制到多个节点），可以提供高吞吐量的数据访问（T级别，多个节点同时处理数据）。</p><p>文件分块存储，HDFS将一个完整的大文件平均分块存储到不同的计算器上，多主机读取比单主机读取效率更高。代码向数据迁移，尽量地将任务分配到离数据最近的机器上运行。</p><a id="more"></a><p>适用情况：大规模数据，流式数据（一次写入多次读写，不支持动态改变文件内容，不支持并发写，小文件不合适。），一般硬件，时间延迟有代价（低时延的访问需求HBase更合适）。</p><h4 id="关键元素"><a href="#关键元素" class="headerlink" title="关键元素"></a>关键元素</h4><p>Block：文件分块，一般大小是64MB or 128MB。配置大的块减少搜寻时间，减少管理块的数据开销，每个块都需要在NameNode上有对应的记录；对数据块进行读写减少建立网络的连接成本。每个块都会被复制到多台机器（可靠性）。</p><p>NameNode：保存整个文件系统的目录信息，文件信息及分块信息。存储文件的metadata，运行时所有数据都保存到内存，整个HDFS可存储的文件数受限于NameNode的内存大小。一个Block在NameNode中对应一条记录</p><p>DataNode：分布在廉价的计算机上，用于存储Block块文件。负责数据的读写操作和复制操作，DataNode启动时会向NameNode报告当前存储的数据块信息。DataNode之间会进行通信，复制数据块，虽然有冗余但是可靠。</p><p>结构如图：</p><p><img src="/images/20200405hadoop_namenode.jpg" alt="20200405hadoop_namenode"></p><p>名称节点（NameNode） 主节点（Master），数据节点 （DataNode） 从节点（Slave）</p><p>名称节点负责文件和目录的创建、删除和重命名等，同时管理数据节点与文件块的映射关系；数据节点负责数据的存储和读取。</p><h4 id="HDFS的数据流—读文件"><a href="#HDFS的数据流—读文件" class="headerlink" title="HDFS的数据流—读文件"></a>HDFS的数据流—读文件</h4><p><img src="/images/20200405HDFS_architecture.jpg" alt="20200405HDFS_architecture"></p><p>客户端client用FileSystem的open() 函数打开文件。</p><p>DistributedFileSystem用RPC调用元数据节点，得到文件的数据块信息。对于每一个数据块，元数据节点返回保存数据块的数据节点的地址。</p><h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p>是一套从海量数据中提取分析元素，最后返回结果集的编程模型。MapReduce的基本原理就是：将大的数据分析分成小块逐个分析，最后再将提取出来的数据汇总分析，最终获得我们想要的内容。</p><p>一种分布式的计算方式指定一个Map函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce（归约）函数，用来保证所有映射的键值对中的每一个共享相同的键组。</p><p><img src="/images/20200405MapReduce.jpg" alt="20200405MapReduce"></p><p>map: (K1, V1) → list(K2, V2) combine: (K2, list(V2)) → list(K2, V2) reduce: (K2, list(V2)) → list(K3, V3)</p><p><img src="/images/20200405MapReduce1.jpg" alt="20200405MapReduce1"></p><p>多节点下流程图：</p><p><img src="/images/20200405mapreduce2.png" alt="20200405mapreduce2"></p><p>Record reader：记录阅读器会翻译由输入格式生成的记录，记录阅读器用于将数据解析给记录，并不分析记录自身。记录读取器的目的是将数据解析成记录，但不分析记录本身。它将数据以键值对的形式传输给mapper。通常键是位置信息，值是构成记录的数据存储块.</p><p>Map：在映射器中用户提供的代码称为中间对。对于键值的具体定义是慎重的，因为定义对于分布式任务的完成具有重要意义.键决定了数据分类的依据，而值决定了处理器中的分析信息。</p><p>Shuffle and Sort：ruduce任务以随机和排序步骤开始。此步骤写入输出文件并下载到本地计算机。这些数据采用键进行排序以把等价密钥组合到一起。</p><p>Reduce：reducer采用分组数据作为输入。该功能传递键和此键相关值的迭代器。可以采用多种方式来汇总、过滤或者合并数据。当ruduce功能完成，就会发送0个或多个键值对。</p><p>输出格式：输出格式会转换最终的键值对并写入文件。默认情况下键和值以tab分割，各记录以换行符分割。因此可以自定义更多输出格式，最终数据会写入HDFS。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，《云计算课程》</p><p>2，W3Cschool： <a href="https://www.w3cschool.cn/hadoop/fgr61jyf.html" target="_blank" rel="noopener">https://www.w3cschool.cn/hadoop/fgr61jyf.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h3&gt;&lt;h3 id=&quot;虚拟化技术&quot;&gt;&lt;a href=&quot;#虚拟化技术&quot; class=&quot;headerlink&quot; title=&quot;虚拟化技术&quot;&gt;&lt;/a&gt;虚拟化技术&lt;/h3&gt;&lt;h3 id=&quot;Hadoop&quot;&gt;&lt;a href=&quot;#Hadoop&quot; class=&quot;headerlink&quot; title=&quot;Hadoop&quot;&gt;&lt;/a&gt;Hadoop&lt;/h3&gt;&lt;p&gt;hadoop是一个开源框架，允许使用简单的编程模型在跨计算机集群的分布式环境中存储和处理大数据。&lt;/p&gt;&lt;h3 id=&quot;HDFS&quot;&gt;&lt;a href=&quot;#HDFS&quot; class=&quot;headerlink&quot; title=&quot;HDFS&quot;&gt;&lt;/a&gt;HDFS&lt;/h3&gt;&lt;p&gt;分布式文件系统，是一个高度容错性的系统（每个数据块都复制到多个节点），可以提供高吞吐量的数据访问（T级别，多个节点同时处理数据）。&lt;/p&gt;&lt;p&gt;文件分块存储，HDFS将一个完整的大文件平均分块存储到不同的计算器上，多主机读取比单主机读取效率更高。代码向数据迁移，尽量地将任务分配到离数据最近的机器上运行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据挖掘" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>分治递归思想</title>
    <link href="http://yoursite.com/2020/03/31/20200330%E5%88%86%E6%B2%BB%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/2020/03/31/20200330%E5%88%86%E6%B2%BB%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3/</id>
    <published>2020-03-31T01:37:21.000Z</published>
    <updated>2022-07-13T14:17:15.778Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分治递归思想"><a href="#分治递归思想" class="headerlink" title="分治递归思想"></a>分治递归思想</h3><p>为了解决一个给定的问题，算法一次或多次递归的调用自身以解决若干子问题，上层函数调用子函数需要等子函数运行完，这些就是典型的分治法的思想。我们将原问题分解为几个规模较小但类似于原问题的子问题，从而递归的调用自身，最后合并这些子问题的解来建立原问题的解。</p><p>关键：1，递：分解原问题为相同结构的子问题。2，解决这些子问题。3，归：合并子问题的解。</p><a id="more"></a><p>注意：调用太深了就可能会堆栈溢出，需要考虑堆栈的深度。</p><h3 id="经典案例"><a href="#经典案例" class="headerlink" title="经典案例"></a>经典案例</h3><h4 id="递归求和"><a href="#递归求和" class="headerlink" title="递归求和"></a>递归求和</h4><p>如果计算1 + 2 + … n ，可以用递归的方法来写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AddFrom1ToN_Recursive</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> n &lt;= <span class="number">0</span>?: <span class="number">0</span>:n + AddFrom1ToN_Recursive(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这里递归比循环的时间复杂度更高，函数递归调用自身都要在内存栈中分配空间保存参数（如n到哪了），返回地址（函数的地址），临时变量（上一次计算得到的AddFrom1ToN_Recursive值）等等，因此空间和时间消耗较多。</p><p>更严重的话递归会带来调用栈溢出的问题，递归调用层级太多就有可能超出栈的容量。</p><h4 id="归并排序。"><a href="#归并排序。" class="headerlink" title="归并排序。"></a>归并排序。</h4><p><a href="[https://saruagithub.github.io/2020/03/10/20200309%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/](https://saruagithub.github.io/2020/03/10/20200309排序算法复习/">排序—归并排序</a>)</p><p>归并排序的详细复杂度分析见 《算法导论》P21，通过递归树分析，总代价是$cnlgn + cn$ (c表示求解规模为1的问题所需要的时间以及在分解步骤与合并步骤处理每个数组元素所需要的时间。)</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="leecode84"><a href="#leecode84" class="headerlink" title="leecode84"></a>leecode84</h4><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p>分析：最大面积是最矮柱子以后，矩形的宽尽可能往两边延伸；or 最矮柱子左边的最大面积矩形 or 最矮柱子右边的最大面积矩形。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculateArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>,<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; <span class="built_in">end</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minindex = start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=start; i&lt;=<span class="built_in">end</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span>[minindex] &gt; <span class="built_in">height</span>[i]) &#123;</span><br><span class="line">            minindex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">height</span>[minindex]*(<span class="built_in">end</span>-start+<span class="number">1</span>) ,<span class="built_in">max</span>( calculateArea(<span class="built_in">height</span>,start,minindex<span class="number">-1</span>), calculateArea(<span class="built_in">height</span>,minindex+<span class="number">1</span>,<span class="built_in">end</span>)) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calculateArea(<span class="built_in">height</span>, <span class="number">0</span>, <span class="built_in">height</span>.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main_recursive</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;largestRectangleArea(nums)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有很多二叉树类的问题都涉及到递归方法。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1, 《算法导论》机械工业出版社 第三版（黑皮的，Thoms H Cormen…）</p><p>2，leecode网站</p><p>3，<a href="https://www.bilibili.com/video/BV1954y1Q7u8/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1954y1Q7u8/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;分治递归思想&quot;&gt;&lt;a href=&quot;#分治递归思想&quot; class=&quot;headerlink&quot; title=&quot;分治递归思想&quot;&gt;&lt;/a&gt;分治递归思想&lt;/h3&gt;&lt;p&gt;为了解决一个给定的问题，算法一次或多次递归的调用自身以解决若干子问题，上层函数调用子函数需要等子函数运行完，这些就是典型的分治法的思想。我们将原问题分解为几个规模较小但类似于原问题的子问题，从而递归的调用自身，最后合并这些子问题的解来建立原问题的解。&lt;/p&gt;&lt;p&gt;关键：1，递：分解原问题为相同结构的子问题。2，解决这些子问题。3，归：合并子问题的解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="http://yoursite.com/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="分治" scheme="http://yoursite.com/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>链表类算法</title>
    <link href="http://yoursite.com/2020/03/29/20200329%E9%93%BE%E8%A1%A8%E7%B1%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/29/20200329%E9%93%BE%E8%A1%A8%E7%B1%BB%E7%AE%97%E6%B3%95/</id>
    <published>2020-03-29T14:26:48.000Z</published>
    <updated>2022-07-13T14:17:15.774Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>用指针来实现线性表，链表是动态的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x),next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h3&gt;&lt;p&gt;用指针来实现线性表，链表是动态的。&lt;/p&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="ListNode" scheme="http://yoursite.com/tags/ListNode/"/>
    
  </entry>
  
  <entry>
    <title>数组实现堆</title>
    <link href="http://yoursite.com/2020/03/28/20200328%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%A0%86/"/>
    <id>http://yoursite.com/2020/03/28/20200328%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%A0%86/</id>
    <published>2020-03-28T09:25:36.000Z</published>
    <updated>2022-07-13T14:17:15.771Z</updated>
    
    <content type="html"><![CDATA[<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>完全二叉树，逐层而下，从左到右，结点的位置完全由其序号觉得，因此可以用数组来实现。</p><p>计算各结点下标的公式，其中$r$ 表示结点的下标，范围在0 ~ n-1 之间，n是二叉树结点的总数。</p><p>$Parent(r)= \lfloor (r-1)/2 \rfloor$ 向下取整，当$r≠0$时</p><p>$Leftchild(r)=2r+1$,当$2r+1&lt;n$时</p><a id="more"></a><p>$Rightchild(r)=2r+2$,当 $2r+2&lt;n$ 时</p><p>$Leftsibling()=r-1$,当r为偶数时</p><p>$Rightsibling()=r+1$ ,当r为奇数并且$r+1&lt;n$时</p><p><img src="/images/20200328Build_heap.jpg" alt="20200328Build_heap"></p><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><p>完全二叉树的一个重要应用是最大堆和最小堆，最小堆就是儿子的值一定不小于父亲的值，树的节点从上到下，从左到右紧凑排列。这里给出最小堆的实现：</p><p>插入数值：在堆的末尾插入，然后不断向上提升，直到没有大小颠倒。</p><p>删除数值：首先把堆的最后一个节点的数值放到根上去，并且删除最后一个节点，然后不断向下交换直到没有大小颠倒为止。向下交换的时候如果2个儿子都比自己小，那么选择数值较小的儿子进行交换。</p><p>复杂度：建堆需要$\Theta(n)$ 的时间，但删除插入都和树深度成正比，时间复杂度是$\Theta(nlogn)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ------------------- min heap --------------------------</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> heap[MAX_N],sz=<span class="number">0</span>; <span class="comment">//sz is global variable, meaning the lengh of heap</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//own node's num.</span></span><br><span class="line">    <span class="keyword">int</span> node_index = sz++;</span><br><span class="line">    <span class="keyword">while</span> (node_index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = (node_index<span class="number">-1</span>)/<span class="number">2</span>; <span class="comment">//i's parent</span></span><br><span class="line">        <span class="keyword">if</span> (heap[p] &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// sequence is ok</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// parent's value put down, node value go up</span></span><br><span class="line">        heap[node_index] = heap[p];</span><br><span class="line">        node_index = p;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[node_index] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">heap_pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// min (root)</span></span><br><span class="line">    <span class="keyword">int</span> rec = heap[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// the new temp root value, get it for compare and move it</span></span><br><span class="line">    <span class="keyword">int</span> x = heap[--sz];</span><br><span class="line">    <span class="comment">//replace from the root</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt; sz) &#123;</span><br><span class="line">        <span class="comment">//compare the children value</span></span><br><span class="line">        <span class="keyword">int</span> a = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = i*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (b &lt; sz &amp;&amp; heap[b] &lt; heap[a]) &#123;</span><br><span class="line">            a = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sequence is right</span></span><br><span class="line">        <span class="keyword">if</span> (heap[a] &gt;= x) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// child's value go up</span></span><br><span class="line">        heap[i] = heap[a];</span><br><span class="line">        i=a;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[i] = x;</span><br><span class="line">    <span class="keyword">return</span> rec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//push(3);</span></span><br><span class="line">    heap_push(<span class="number">9</span>);</span><br><span class="line">    heap_push(<span class="number">2</span>);</span><br><span class="line">    heap_push(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sz; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;heap[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"pop:"</span>&lt;&lt;heap_pop()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"pop:"</span>&lt;&lt;heap_pop()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ------ standard package is the max queue ------</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; qqueue;</span><br><span class="line">    qqueue.push(<span class="number">-9</span>);</span><br><span class="line">    qqueue.push(<span class="number">-2</span>);</span><br><span class="line">    qqueue.push(<span class="number">-6</span>);</span><br><span class="line">    <span class="comment">//loop until it is empty</span></span><br><span class="line">    <span class="keyword">while</span> (!qqueue.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span> * qqueue.top()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        qqueue.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>1，《数据结构与算法分析》 Clifford A. Shaffer 等</p><p>2，《挑战程序设计》</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;完全二叉树&quot;&gt;&lt;a href=&quot;#完全二叉树&quot; class=&quot;headerlink&quot; title=&quot;完全二叉树&quot;&gt;&lt;/a&gt;完全二叉树&lt;/h3&gt;&lt;p&gt;完全二叉树，逐层而下，从左到右，结点的位置完全由其序号觉得，因此可以用数组来实现。&lt;/p&gt;&lt;p&gt;计算各结点下标的公式，其中$r$ 表示结点的下标，范围在0 ~ n-1 之间，n是二叉树结点的总数。&lt;/p&gt;&lt;p&gt;$Parent(r)= \lfloor (r-1)/2 \rfloor$ 向下取整，当$r≠0$时&lt;/p&gt;&lt;p&gt;$Leftchild(r)=2r+1$,当$2r+1&amp;lt;n$时&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="堆" scheme="http://yoursite.com/tags/%E5%A0%86/"/>
    
      <category term="完全二叉树" scheme="http://yoursite.com/tags/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>20200325word的xml无效而无法打开</title>
    <link href="http://yoursite.com/2020/03/26/20200325word%E7%9A%84xml%E6%97%A0%E6%95%88%E8%80%8C%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80/"/>
    <id>http://yoursite.com/2020/03/26/20200325word%E7%9A%84xml%E6%97%A0%E6%95%88%E8%80%8C%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80/</id>
    <published>2020-03-26T01:07:58.000Z</published>
    <updated>2022-07-13T14:17:15.760Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>写论文生成word的时候出现了xml无效的问题。</p><p><img src="/images/20200325word_problem1.jpg" alt="20200325word_problem1"></p><p>将word文档原扩展名“docx”手动改为压缩文件扩展名“zip”，备份一个，然后用解压软件解压。用vscode编辑器或者其他的一些xml编辑器（如firstobject）打开解压文件夹下的word目录下的document.xml 文件。根据对xml错误提示进行更改。</p><a id="more"></a><p>我这里提示的错误是：起始标记“mc:Fallback”（偏移位置 1732371）在偏移位置 1733790缺少对应的结束标记。则将鼠标移动到 1733790个字节的位置，说明这里缺少了 ＜/mc:Fallback＞，注意英文输入。 </p><p>然后重复分析xml文档的缺失，直到没有任何问题。其中遇到了下图这个最后的问题，这个问题是直接缺了 ＜ /w:r＞这个标签，怎么分析的呢？是查找对比前面的几对Fallback的格式发现的缺失，这个就要好好对比一下了。</p><p><img src="/images/20200325word_problem2.jpg" alt="20200325word_problem2"></p><h3 id="重新打开"><a href="#重新打开" class="headerlink" title="重新打开"></a>重新打开</h3><p>最后将改完的xml替换原来的xml，再将“.zip”改回”.dcox“文档，再次打开word文件就可以打开了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;写论文生成word的时候出现了xml无效的问题。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/20200325word_problem1.jpg&quot; alt=&quot;20200325word_problem1&quot;&gt;&lt;/p&gt;&lt;p&gt;将word文档原扩展名“docx”手动改为压缩文件扩展名“zip”，备份一个，然后用解压软件解压。用vscode编辑器或者其他的一些xml编辑器（如firstobject）打开解压文件夹下的word目录下的document.xml 文件。根据对xml错误提示进行更改。&lt;/p&gt;
    
    </summary>
    
    
      <category term="配置" scheme="http://yoursite.com/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="配置" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
      <category term="word" scheme="http://yoursite.com/tags/word/"/>
    
  </entry>
  
  <entry>
    <title>Unsupervised Anomaly Detection via Variational Auto-Encoder for Seasonal KPIs in Web Applications (Donut model, Part Ⅱ)</title>
    <link href="http://yoursite.com/2020/03/14/20200314paper-Unsupervised-Anomaly-Detection-via-Variational-AutoEncoder-for-Seasonal-KPIs-in-Web-Applications(Part2)/"/>
    <id>http://yoursite.com/2020/03/14/20200314paper-Unsupervised-Anomaly-Detection-via-Variational-AutoEncoder-for-Seasonal-KPIs-in-Web-Applications(Part2)/</id>
    <published>2020-03-14T09:40:12.000Z</published>
    <updated>2022-07-13T14:17:15.751Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Evaluation实验"><a href="#Evaluation实验" class="headerlink" title="Evaluation实验"></a>Evaluation实验</h3><h4 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h4><p>我们从大型互联网上获得了18个维护良好的商业KPIs（时间跨度足以进行培训和评估），所有的KPIs间隔为1min。三个数据集 A B C 如图6的Table1。因此我们可以评估Donut在不同级别的噪声。 我们将每个数据集分为训练集 49%，验证集21%和测试集30%。</p><a id="more"></a><p><img src="/images/20200314Donut_Dataset.jpg" alt="20200314Donut_Dataset"></p><h4 id="Performance-Metric度量指标"><a href="#Performance-Metric度量指标" class="headerlink" title="Performance Metric度量指标"></a>Performance Metric度量指标</h4><p>评估中，完全忽略了所有算法在缺失点（“空”）的输出。本文所有评估的算法为每个点计算一个异常分数，选择一个阈值来进行决策：如果某个点的分数大于阈值，则应该触发警报。这样，异常检测就类似于分类问题，并且我们可以计算与每个阈值相对应的精度和召回率。给定所有可能的阈值，我们可以进一步计算AUC，即召回率的平均精度。或F分数，它是给定一个特定阈值的精度和召回率的谐平均值。我们还可能枚举所有阈值，获得所有F分数，并使用最佳F分数作为度量。给定最佳全局阈值，最好的F分数表示模型在特定测试集上的最佳性能。在实践中，最佳F分数与AUC基本一致，除了细微差异（见图8）。<strong>相比AUC我们更喜欢best F-score</strong>，因为在某个阈值上拥有出色的F分数比在大多数阈值上拥有高但不是那么出色的F分数更为重要。</p><p>简单评估策略：在实际应用中，操作员通常并不关心逐点度量。 如果延迟不太长，触发连续异常段中任何点的警报都是可接受的。 已经提出了一些用于异常检测的度量来适应这种偏好，例如，[22 NAB]，但是大多数度量没有被广泛接受，这可能是因为它们太复杂了。 相反，我们使用一种简单的策略：如果可以通过选定的阈值检测到真实异常段中的任何点，那么我们就说该段被正确检测了，并且将该段中的所有点都视为可以被此段检测到。 同时，异常段外的点将照常处理。 然后相应地计算精度，召回率，AUC，F-score和best F-score。 图7中说明了这种方法。alert delay = 警报分段中第一个点与第一个检测到的点之间的时间差。</p><p><img src="/images/20200314Metric.jpg" alt="20200314Metric"></p><h4 id="Experiment-启动"><a href="#Experiment-启动" class="headerlink" title="Experiment 启动"></a>Experiment 启动</h4><p>参数设置：我们设置窗口大小W = 120，即2h。W的选择受到两个因素的限制。 一方面，W太小将导致模型无法捕获模式，因为模型被期望识别出那些仅来自窗口的正常模式，（请参阅第5.1节）。 另一方面，W太大会增加过度拟合的风险，因为我们用没有权值共享的全连接层，因此模型参数的数量与W成正比。我们将B和C的潜在维度K设置为3，因为3维空间可以很容易地可视化以便分析。隐藏层的 $q_{\phi}(\mathbf{z} | \mathbf{x})$ 和 $p_{\theta}(\mathbf{x} | \mathbf{z})$ 都选择作两个ReLU层，每个ReLU层具有100个单位，这使得变分和生成网络具有相等的大小。我们没有对隐藏网络的结构进行详尽的搜索。</p><p>其他超参： std 层的 $\epsilon = 10^{-4}$ ，injection ratio = $\lambda$ ,  MCMC 迭代次数M = 10， 蒙特卡洛积分的采样数量$L = 1024$ ，训练的batch size = 256，运行250 Epochs，优化器是 Adam[15]，初始学习率是 $10^{-3}$ ，每过10Epochs就将学习率折0.75，对隐藏层采用L2正则化其系数coefficient = $10^{-3}$。 我们按标准裁剪clip梯度，限制为10.0。 </p><p>标签说明：为了评估没有标签的Donut，我们将忽略所有标签。 对于偶有的标签，我们对训练和验证集的异常标签进行下采样，以使其包含10％的标记异常。 请注意，缺失点不会被下采样。 我们一直随机丢弃异常片段，其概率与每个片段的长度成正比，直到达到所需的下采样率。 我们使用这种方法，而不是随机丢弃单个异常点，因为KPI是时间序列，并且每个异常点都可能泄漏有关其邻近点的信息，从而导致性能被高估。 这样的下采样完成了10次，这使我们能够进行10个独立的重复实验。 对于每个数据集，总体而言，我们有三个版本：0％标签，10％标签和100％标签。</p><h4 id="总体性能"><a href="#总体性能" class="headerlink" title="总体性能"></a>总体性能</h4><p>我们比较AUC，best F-score和平均alert delay，与三种算法相比，如图8：</p><p><img src="/images/20200314compare_metric.jpg" alt="20200314compare_metric"></p><p>比较的算法：Opprentice[25]，VAE baselin[2] 基于VAE的异常检测不处理时间序列，因此我们按以下方法设置VAE基模型。 首先，VAE基模型具有与Donut相同的网络结构，如图4所示。其次，在图3中的所有技术中，仅使用“数据准备”步骤中的那些技术。 第三，正如[2]所建议的，我们从训练数据中排除所有包含标记异常或缺失点的窗口。 Donut-Prior算法，给定一个生成模型自然学习 $p(x)$ ，而在VAE $p(x)$ 被定义为 $\mathbb{E}_{\boldsymbol{p}_{\theta}(\mathbf{z})}\left[p_{\theta}(\mathbf{x} | \mathbf{z})\right]$ ，我们还评估了重建概率的先前部分 $\mathbb{E}_{p_{\theta}(\mathbf{z})}\left[\log p_{\theta}(\mathbf{x} | \mathbf{z})\right]$。 我们只需要先验的基模型，因此我们可以通过简单的蒙特卡洛积分来计算先验期望，而无需使用先进的技术来改善结果。</p><p>The best F-score of Donut is quite satisfactory in totally unsu- pervised case, ranges from 0.75 to 0.9, </p><p>Donut，Opprentice和VAE Baseline的平均警报延迟在所有数据集中都是可接受的</p><h4 id="Donut技术的效果"><a href="#Donut技术的效果" class="headerlink" title="Donut技术的效果"></a>Donut技术的效果</h4><p>我们提出的三种技术的各自的作用(1) M-ELBO (Eqn (3)), (2) missing data injection, and (3) MCMC imputation。我们通过这些技术的四种可能的组合展示了Donut的最佳F分数：</p><p><img src="/images/202003154Tech-BestF-score.jpg" alt="202003154Tech-BestF-score"></p><p>仅M-ELBO就能在VAE基模型上做出大部分改进。 它通过训练Donut来适应x中可能出现的异常点并在这种情况下产生所需的输出而起作用。尽管对于生成模型来说很自然（第5.2节），但仅使用正常数据来训练VAE以进行异常检测不是一个好习惯。</p><p>丢失数据注入是为增强M-ELBO的效果而设计的，实际上可以看作是一种数据增强方法。我们仅注入遗漏的点。由于缺少数据注入而导致的最佳F分数的提高不是很明显。注射会给训练带来额外的随机性，因此需要更大的训练时间。</p><p>MCMC imputation还旨在帮助Donut处理异常点。 尽管Donut仅在某些情况下使用MCMC获得了最佳F评分的显着改善，但它从未损害性能。 根据[32]，这应该是预期的结果。 因此，我们建议在检测中始终采用MCMC。</p><h4 id="分析K的影响。"><a href="#分析K的影响。" class="headerlink" title="分析K的影响。"></a>分析K的影响。</h4><p>$z$ 的维度 K很重要。K太小可能会导致拟合不足或次优平衡（请参见第5.4节）。 另一方面，K太大可能会导致重建概率无法找到好的后验概率（请参阅第5.1节）。 在完全不受监督的情况下很难选择一个好的K，因此我们将其留作未来的工作。</p><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>我们在此提出针对重建概率以及整个Donut算法的KDE（内核密度估计）解释。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Evaluation实验&quot;&gt;&lt;a href=&quot;#Evaluation实验&quot; class=&quot;headerlink&quot; title=&quot;Evaluation实验&quot;&gt;&lt;/a&gt;Evaluation实验&lt;/h3&gt;&lt;h4 id=&quot;Datasets&quot;&gt;&lt;a href=&quot;#Datasets&quot; class=&quot;headerlink&quot; title=&quot;Datasets&quot;&gt;&lt;/a&gt;Datasets&lt;/h4&gt;&lt;p&gt;我们从大型互联网上获得了18个维护良好的商业KPIs（时间跨度足以进行培训和评估），所有的KPIs间隔为1min。三个数据集 A B C 如图6的Table1。因此我们可以评估Donut在不同级别的噪声。 我们将每个数据集分为训练集 49%，验证集21%和测试集30%。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AIOps" scheme="http://yoursite.com/categories/AIOps/"/>
    
    
      <category term="AIOps" scheme="http://yoursite.com/tags/AIOps/"/>
    
      <category term="论文" scheme="http://yoursite.com/tags/%E8%AE%BA%E6%96%87/"/>
    
      <category term="AnomalyDetection" scheme="http://yoursite.com/tags/AnomalyDetection/"/>
    
  </entry>
  
</feed>
